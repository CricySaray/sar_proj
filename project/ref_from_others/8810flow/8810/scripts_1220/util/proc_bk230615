
proc userRunTimeCalculation {args} {
	global vars
	global second_start
	set start_timing false
	set end_timing false
	foreach arg $args {
		switch -exact $arg {
			"-start"		{ set start_timing true}
			"-end"			{ set end_timing true }
		}
	}
	set current_timing [exec date "+%4y %2m %2d %2H %2M"]
	set second [exec date "+%s"]
        set year [lindex $current_timing 0]
        set month [lindex $current_timing 1]
        set day [lindex $current_timing 2]
        set hour [lindex $current_timing 3]
        set minute [lindex $current_timing 4]
	if {$start_timing } {
		puts "*************************************************************************"
		puts "*******invs $vars(step) job start at $month\\$day $hour:$minute  ..."
		set year_start $year
		set month_start $month
		set day_start $day
		set hour_start $hour
		set minute_start $minute
		set second_start $second
		puts "*************************************************************************"
	}
	if {$end_timing } {
		puts "*************************************************************************"
		puts "*******invs $vars(step) job end at $month\\$day $hour:$minute  ..."
		set year_end $year
		set month_end $month
		set day_end $day
		set hour_end $hour
		set minute_end $minute
		set second_end $second
		set run_timing_hour [expr ($second_end - $second_start) / 3600 ]
		set run_timing_minute [expr ($second_end - $second_start -$run_timing_hour * 3600 ) / 60 ]
		puts " ******INVS $vars(step) RUN TIMING USED $run_timing_hour hour: $run_timing_minute minute **********"
		puts "*************************************************************************"
	}
}
	
	

proc userNetWeight { a b c} {
	set num 0
	dbForEachCellInst [dbgTopCell] instPtr {
		set inst [dbInstName $instPtr]
		set cell [dbCellName [dbInstCell $instPtr]]
		if {[regexp "$a" $cell]} {
			incr num
			set termPtr [dbGetTermByInstTermName [dbInstName $instPtr]/$b]]	
			set net [dbTermNet $termPtr]
		if {$net == "0"} {
			continue
		} else {
			specifyNetWeight [dbNetName $net] $c
			}
		}
	}
	puts "Total $num cell have been set a net weight"
}
proc userGetPowerDomains { } {
	set power_domains [list]
	dbForEachPowerDomain [dbgHead] pd {
		lappend power_domains [dbPowerDomainName $pd]	
	}
	return $power_domains
}
proc userAddFillerCells {} {
	global vars
	set prefix FILL
	setFillerMode -corePrefix $prefix -core $vars(filler_cells) -fitGap true
	if {[info exists vars(lp_mode)] && $vars(lp_mode)=="true"} {
		set vars(power_domains) [userGetPowerDomains]
		foreach domain $vars(power_domains) {
			if {[dbPowerDomainNrInst [dbGetPowerDomainByName $domain]] > 0} {
				if {[info exists vars(filler_cells)]} {
					addFiller -powerDomain $domain -doDRC false
				}
			}
		}
	} elseif {[info exists vars(filler_cells)]} {
		addFiller  -doDRC false
	}
}
proc userAddTieCells {} {
	global vars
	if {[info exists vars(lp_mode)] && $vars(lp_mode)=="true"} {
		set vars(power_domains) [userGetPowerDomains]
		foreach domain $vars(power_domains) {
			if {[dbPowerDomainNrInst [dbGetPowerDomainByName $domain]] > 0} {
				if {[info exists vars(tie_cells)]} {
					foreach cell $vars(tie_cells) {
						set_dont_use $cell false
					}
				}
				setTieHiLoMode -cell $vars(tie_cells) -maxFanOut 1 -maxDistance 5
				addTieHiLo -powerDomain $domain -prefix domain_
			}
		}
	} elseif {[info exists vars(tie_cells)]} {
		foreach cell $vars(tie_cells) {
		         set_dont_use $cell false
		}
		setTieHiLoMode -cell $vars(tie_cells) -maxFanOut 1 -maxDistance 50
		addTieHiLo
	}
}



proc checkFloat args {
	set user_options $args
	set textFile [open ./chekFloating.input w]
	set inTermPtr [dbGet -p top.insts.instTerms.isInput 1]
	foreach inPtr $inTermPtr {
		set inTermName [dbGet $inPtr.name]
		set netName [dbGet $inPtr.net.name]
		foreach net $netName {
			if {$net == "0x0"} {
				puts $textFile "inTermName\n"
			}
		}
	}
	close $textFile
	puts "checkFloatIn output FIle: checkFloating.input"
}
proc checkTieHiLo args {
	set user_options $args
	set PwrGndNetName [dbGet [dbGet -p top.phyNets.isPwrOrGnd 1].name]
	set PwrGndNetPtr [dbGet [dbGet -p top.phyNets.isPwrOrGnd 1]
	foreach NetName $PwrGndNetName NetPtr $PwrGndNetPtr {
		set numInputTerms [dbGet ${NetPtr}.numInputTerms]
		set allTermsName [dbGet ${netPtr}.allTerms.name]
		if {$numInputTerms != 0} {
			set TextFile [open ${NetName}.inputTerm w]
			foreach termName $allTermsName {
				puts $TextFile "$termName"
			}
			close $TextFile
			puts "ERROR,$netName miss tiehi or tielo cell"
		}
	}
}
proc macro_pgpin_nonconnect args {
	set user_options $args
	set textFile [open ./chekfloating.pgpin w]
	set pgTermPtr [dbGet top.insts.pgInstTerms]
	foreach inPtr $pgTermPtr {
		set inTermName [dbGet $inPtr.name]
		foreach term $inTermName {
			if { $term != "0x0" } {
				set netName [dbGet $inPtr.net.hNets.name]
				set instName [dbGet $inPtr.inst.name]
				if { $netName == "0x0"} {
					puts "waring : instance $instName  pg pin $inTermName connect to \"NULL\",please check and fix it"
					puts $textFile "waring : instance $instName  pg pin $inTermName connect to \"NULL\",please check and fix it"
				}
			}
		}
	}
	close $textFile
}
proc userSaveDesign {args} {
	global vars
	#parse options
	set help false
	set release false
	set addfiller false
	set mergegds false
#	set view_name "[exec date "+%y%m%d"]"
#	set dir_name "[dbgDesignName]_$view_name"
	set type_name all
	set base_path [pwd]
	foreach arg $args {
		incr index
		switch -exact $arg {
			"-dir"		{ set dir_name [lindex $args $index] }
			"-view"		{ set view_name [lindex $args $index] }
			"-type"		{ set type_name [lindex $args $index] }
			"-pwr_net"	{ set pwr_net_name [lindex $args $index] }
			"-gnd_net"	{ set gnd_net_name [lindex $args $index] }
			"-release"	{ set release true }
			"-addfiller"	{ set addfiller true }
			"-merge"	{ set mergegds true }
			"-help"	{ set help true }
			"-h"	{ set help true}
		}
	}
	#check options
	if { $help } {
		puts "Usage : EDI design data export ."
		puts " 		-release 			: release mode for  fullchip assemble ,data will be saved to dsn/release/ dir"
		puts " 		-dir 				: specify release mode export directory name ,default values is data"
		puts " 		-type 				: specify export data typ ,you can select all ,pa ,pv"
		puts " 		-view				: specify export view name,default vaule is default"
		puts " 		-pwr_net			: specify power net name for pa source loaction extraction,"
		puts " 		-gnd_net			: specify gnd net name for pa source loaction extraction,"
		puts " 		-addfiller			: specify automatic and cap &filler or not"
		puts "		-merge				: specify merge base cell into gds or not"
		puts "example"
		puts "userSaveDesign -release -dir 1011 -view all -type all -pwr_net vdd -gnd_net vss" 
	} else {
		set dir_name "[dbgDesignName]_$view_name"
		#create directory &varialbe
		set dum_excl_file ""
		set netlist_file ""
		set pg_netlist_file ""
		set lvs_netlist_file ""
		set fp_file ""
		set def_file ""
		set pr_gds_file ""
		set merge_gds_file ""
		set db_file ""
		set rhwk_pg_loc_file ""
		set wps_power_loc_file ""
		set wps_ground_loc_file ""
		set def_for_ice ""
		set ir_gds_file ""
		set lp_gsc_file ""
		if {$release} {
			exec mkdir -p $base_path/../../dsn/release
			exec mkdir -p $base_path/../../dsn/release/$dir_name
			exec mkdir -p $base_path/../../dsn/release/$dir_name/db
			exec mkdir -p $base_path/../../dsn/release/$dir_name/def
			exec mkdir -p $base_path/../../dsn/release/$dir_name/gate
			exec mkdir -p $base_path/../../dsn/release/$dir_name/gds
			exec mkdir -p $base_path/../../dsn/release/$dir_name/spf
			exec mkdir -p $base_path/../../dsn/release/$dir_name/cdl
			exec mkdir -p $base_path/../../dsn/release/$dir_name/pwr
			exec mkdir -p $base_path/../../dsn/release/$dir_name/pwr/ploc
			exec mkdir -p $base_path/../../dsn/release/$dir_name/pwr/gsc
			exec mkdir -p $base_path/../../dsn/release/$dir_name/sdf
			set dsn_db_dir "$base_path/../../dsn/release/$dir_name/db"
			set dsn_def_dir "$base_path/../../dsn/release/$dir_name/def"
			set dsn_gate_dir "$base_path/../../dsn/release/$dir_name/gate"
			set dsn_gds_dir "$base_path/../../dsn/release/$dir_name/gds"
			set dsn_spf_dir "$base_path/../../dsn/release/$dir_name/spf"
			set dsn_cdl_dir "$base_path/../../dsn/release/$dir_name/cdl"
			set dsn_pwr_dir "$base_path/../../dsn/release/$dir_name/pwr"
			exec mkdir -p $base_path/../../dsn
			exec mkdir -p $base_path/../../dsn/db
			exec mkdir -p $base_path/../../dsn/def
			exec mkdir -p $base_path/../../dsn/gate
			exec mkdir -p $base_path/../../dsn/gds
			exec mkdir -p $base_path/../../dsn/spf
			exec mkdir -p $base_path/../../dsn/cdl
			exec mkdir -p $base_path/../../dsn/pwr
			exec mkdir -p $base_path/../../dsn/pwr/ploc
			exec mkdir -p $base_path/../../dsn/pwr/gsc
			set ctsexcl_gds_dir "$base_path/../../dsn/gds"
		} else {
			exec mkdir -p $base_path/../../dsn
			exec mkdir -p $base_path/../../dsn/db
			exec mkdir -p $base_path/../../dsn/def
			exec mkdir -p $base_path/../../dsn/gate
			exec mkdir -p $base_path/../../dsn/gds
			exec mkdir -p $base_path/../../dsn/spf
			exec mkdir -p $base_path/../../dsn/cdl
			exec mkdir -p $base_path/../../dsn/pwr
			exec mkdir -p $base_path/../../dsn/pwr/ploc
			exec mkdir -p $base_path/../../dsn/pwr/gsc
			set dsn_db_dir "$base_path/../../dsn/db"
			set dsn_def_dir "$base_path/../../dsn/def"
			set dsn_gate_dir "$base_path/../../dsn/gate"
			set dsn_gds_dir "$base_path/../../dsn/gds"
			set dsn_spf_dir "$base_path/../../dsn/spf"
			set dsn_cdl_dir "$base_path/../../dsn/cdl"
			set dsn_pwr_dir "$base_path/../../dsn/pwr"
			set ctsexcl_gds_dir "$base_path/../../dsn/gds"
		}
		##defout _without filler and decap for ice timing fix
		#defOut -floorplan -netlist -routing $dsn_def/dir/[dbgDesignName].ice.${view_name}.def.gz
		#set def_for_ice "$dsn_def_dir/[dbgDesignName].ice.${view_name}.def.gz"
		#--------------------------------------------------------
		#insert filler cell
		#--------------------------------------------------------
		if {$addfiller} {
			set prefix DCAP_FILL
			if {$vars(lp_mode) !=""} {
				set vars(power_domains) [userGetPowerDomains]
				foreach domain $vars(power_domains) {
					if {[dbPowerDomainNrInst [dbGetPowerDomainByName $domain]]>0 } {
						if {[nfo exists vars(decap_cell)]} {
							if { $vars(process) < 28 } {
								clearDrc
								set_verify_drc_mode -limit 1000000 -check_implant false
								setFillerMode -reset
								setFillerMode -corePrefix $prefix -core $vars(decap_cell) -add_fillers_with_drc false
								setFillerMode -verticalStackMaxLength 200 -verticalStackExceptionCell "$vars(filler1_cells) [dbget head.libCells.name TAPCELLBWP*] [dbget head.libCells.name BOUNDARY*]"
								addFiller -powerDomain $domain -doDRC true -fixVerticalStackMaxLengthViolation
							} else {
								setFillerMode -corePrefix $prefix -core $vars(decap_cell) -fitGap true -add_fillers_with_drc false
								addFiller -powerDomain $domain -doDRC true
							}
						}
					}
				}
			} elseif {[info exists vars(decap_cell)]} {
				if { $vars(process) < 28 } {
					clearDrc
					set_verify_drc_mode -limit 1000000 -check_implant false
					setFillerMode -reset
					setFillerMode -corePrefix $prefix -core $vars(decap_cell) -add_fillers_with_drc false
					setFillerMode -verticalStackMaxLength 200 -verticalStackExceptionCell "$vars(filler1_cells) [dbget head.libCells.name TAPCELLBWP*] [dbget head.libCells.name BOUNDARY*]"
			#		addFiller -powerDomain $domain -doDRC true -fixVerticalStackMaxLengthViolation
					addFiller -doDRC true -fixVerticalStackMaxLengthViolation
				} else {
					setFillerMode -corePrefix $prefix -core $vars(decap_cell) -fitGap true -add_fillers_with_drc false
	#				addFiller -powerDomain $domain -doDRC true
					addFiller -doDRC true
				}
			}

			set prefix FILL
			if {[info exists vars(lp_mode)] && $vars(lp_mode) ==""} {
				set vars(power_domains) [userGetPowerDomains]
				foreach domain $vars(power_domains) {
					if {[dbPowerDomainNrInst [dbGetPowerDomainByName $domain]]>0 } {
						if {[info exists vars(filler_cells)]} {
							if { $vars(process) < 28 } {
								clearDrc
								set_verify_drc_mode -limit 1000000 -check_implant false
								setFillerMode -reset
								setFillerMode -corePrefix $prefix -core $vars(filler_cells)
								setFillerMode -verticalStackMaxLength 200 -verticalStackExceptionCell "$vars(filler1_cells) [dbget head.libCells.name TAPCELLBWP*] [dbget head.libCells.name BOUNDARY*]"
								addFiller -powerDomain $domain -doDRC false -fixVerticalStackMaxLengthViolation
							} else {
								setFillerMode -corePrefix $prefix -core $vars(filler_cells) -fitGap true
								addFiller -powerDomain $domain -doDRC false
							}
						}
					}
				}
			} elseif {[info exists vars(filler_cells)]} {
				if { $vars(process) < 28 } {
					clearDrc
					set_verify_drc_mode -limit 1000000 -check_implant false
					setFillerMode -reset
					setFillerMode -corePrefix $prefix -core $vars(filler_cells)
					setFillerMode -verticalStackMaxLength 200 -verticalStackExceptionCell "$vars(filler1_cells) [dbget head.libCells.name TAPCELLBWP*] [dbget head.libCells.name BOUNDARY*]"
	#				addFiller -powerDomain $domain -doDRC true -fixVerticalStackMaxLengthViolation
					addFiller -doDRC false -fixVerticalStackMaxLengthViolation
				} else {
					setFillerMode -corePrefix $prefix -core $vars(filler_cells) -fitGap true
#					addFiller -powerDomain $domain -doDRC true
					addFiller -doDRC false
				}
			}

		 	## globalconnect for vstack_postfix _inst,abug of edi
			if {$vars(process) < 28 } {	
				if { [userGetPowerDomains] == " " } {
					foreach instName [dbget top.insts.name *VSTACK_POST_*] {
						set instPtr [dbGetInstByName $instName]
						set pwrPin [dbget [dbget -p1 ${instPtr}.cell.pgTerms.type powerTerm].name]
						set gndPin [dbget [dbget -p1 ${instPtr}.cell.pgTerms.type groundTerm].name]
						globalNetConnect $vars(pwr_nets) -override -pin $pwrPin -singleInstance $instName -type pgpin
						globalNetConnect $vars(gnd_nets) -override -pin $gndPin -singleInstance $instName -type pgpin
					}
				} else {
					dbForEachPowerDomain [dbgHead] pd {
						set pdName [dbget ${pd}.name]
						if {[dbPowerDomainNrInst $pd] > 0 } {
							set n($pdName) "$CPF::pd_intnets($pdName,power) $CPF::pd_intnets($pdName,ground)"
						}
					}
					foreach instName [dbget top.insts.name *VSTACK_POST_*] {
						set instDom [getInstPowerDomain $instName]
						set instPtr [dbGetInstByName $instName]
						set pwrPin [dbget [dbget -p1 ${instPtr}.cell.pgTerms.type powerTerm].name]
						set gndPin [dbget [dbget -p1 ${instPtr}.cell.pgTerms.type groundTerm].name]
						globalNetConnect [lindex $n($instDom) 0] -override -pin $pwrPin -singleInstance $instName -type pgpin
						globalNetConnect [lindex $n($instDom) 1] -override -pin $gndPin -singleInstance $instName -type pgpin
				
					}
				}
			}

			checkPlace
			if {$vars(process) < 28 } {	
				checkFiller -verticalStackMaxLength
			} else {
				checkFiller -reportGap [expr $vars(min_gap)/2]
			}
		}
		if { $type_name == "all" } {
			##delete empty module
			deleteDanglingPort
			deleteEmptyModule
            #for tsmc22ull@20211015
            if { $vars(library) == "TSMC22ULL" } {
                deselectAll
                editSelect -type Special -shape FOLLOWPIN -layer M1 -subclass M1_follow_pin
                editSelect -type Special -shape FOLLOWPIN -layer M2 -subclass M2_follow_pin
                setViaGenMode -viarule_preference  {VIAGEN12} -ignore_DRC false -respect_signal_routes 1 -respect_stdcell_geometry true -disable_via_merging 1 -allow_wire_shape_change false
                editPowerVia -add_vias 1 -bottom_layer M1 -orthogonal_only 0 -top_layer M2 -between_selected_wires 1 -uda m1_m2_pg_via -split_long_via {2 0.13 0.055}
                deselectAll
                setViaGenMode -reset
                #WA for ignore_DRC fail
                clearDrc
                verify_drc -layer_range {M1 M2} -limit 1000000 -check_only special
                set markers [dbGet [dbGet top.markers {.subType == "Cut_EOL_Spacing" || .subType == "Cut_Spacing"}].layer.name VIA1 -p2]
                if {$markers != "0x0"} {
                    set vias [dbGet [dbQuery -areas [dbGet ${markers}.box] -objType sViaInst -layers VIA1].userClass m1_m2_pg_via -p]
                    deselectAll
                    select_obj $vias
                    editDelete -selected
                }
            } else {
            }

			## export dummy cts blk
			set file [open $dsn_gds_dir/[dbgDesignName].ctsdum.${view_name}.tcl w]
			puts $file "set Lnew \[layout create\]"
			puts $file "\$Lnew create cell [dbgDesignName]_CRITICAL_NET"
			puts $file "\$Lnew create layer 31"
                        puts $file "\$Lnew create layer 32"
                        puts $file "\$Lnew create layer 33"
                        puts $file "\$Lnew create layer 34"
                        puts $file "\$Lnew create layer 35"
                        puts $file "\$Lnew create layer 36"
                        puts $file "\$Lnew create layer 37"
                        puts $file "\$Lnew create layer 38"

			for { set i 2 } {$i < [expr $vars(max_route_layer) +1] } {incr i 1} {
				deselectAll
				editSelect -use CLOCK -layer $i
				if {$vars(process) < 28 } {
					set extendWidth [expr [dbget [dbGetLayerByName $i].width] * 2]
				} else {
					set extendWidth [expr [dbget [dbGetLayerByName $i].width] * 4]
				} 
				set box_list [dbget selected.box]
				foreach box $box_list {
					set lox1 [expr [lindex $box 0] - $extendWidth]
					set loy1 [expr [lindex $box 1] - $extendWidth]
					set lox2 [expr [lindex $box 2] - $extendWidth]
					set loy2 [expr [lindex $box 3] - $extendWidth]
					set lox1_u [expr int ( $lox1 *1000)]
					set loy1_u [expr int ( $loy1 *1000)]
					set lox2_u [expr int ( $lox2 *1000)]
					set loy2_u [expr int ( $loy2 *1000)]

					if {$i == $vars(max_route_layer) } {
							puts $file "\$Lnew create polygon [dbgDesignName]_CRITICAL_NET [expr $i + 30] $lox1_u $loy1_u $lox2_u $loy1_u $lox2_u $loy2_u $lox1_u $loy2_u"
					} else {
							puts $file "\$Lnew create polygon [dbgDesignName]_CRITICAL_NET [expr $i + 30] $lox1_u $loy1_u $lox2_u $loy1_u $lox2_u $loy2_u $lox1_u $loy2_u"
					}
				}
			}
			deselectAll
			puts $file "\$Lnew gdsout $ctsexcl_gds_dir/[dbgDesignName].ctsdumyexlude.${view_name}.gds.gz"
			close $file
			set dum_excl_file "$dsn_gds_dir/[dbgDesignName].ctsdum.${view_name}.tcl"
			##verilog 
			saveNetlist $dsn_gate_dir/[dbgDesignName].pr.${view_name}.vg.gz
			saveNetlist -excludeLeafCell -includePowerGround -excludeTopCellPGPort $vars(exlude_pg_list) -includePhysicalCell $vars(pg_physical_cells) $dsn_gate_dir/[dbgDesignName].pg.${view_name}.vg.gz
			set netlist_file "$dsn_gate_dir/[dbgDesignName].pr.${view_name}.vg.gz"
			set pg_netlist_file "$dsn_gate_dir/[dbgDesignName].pg.${view_name}.vg.gz"
			
			##clp verilog 
			#saveNetlist -excludeLeafCell -includePowerGround $dsn_gate_dir/[dbgDesignName].pr.clp.${view_name}.vg.gz
			#set clp_netlist_file "$dsn_gate_dir/[dbgDesignName].pr.clp.${view_name}.vg.gz"
			##physcial verilog netlist export
			#serach exculde cell list
			set excludeCellInstList ""
#			foreach cellName [dbGet -u head.allCells.physInsts.cell.name] {
#				if {[regexp "CUT" $cellName] } {
#					lappend excludeCellInstList $cellName
#				} else {
#					if {[dbGet [dbGet -p1 head.allCells.isTimeDefined 1].name $cellName] =="0x0" } {
#						lappend excludeCellInstList $cellName
#					}
#				}
#			}
			foreach cell $vars(exclude_cells) {
				if { [dbGet head.libCells.name $cell] != "0x0" } {
                    foreach c [dbGet head.libCells.name $cell] {
						lappend excludeCellInstList $c
					}
				}

			}
			saveNetlist -phys -excludeLeafCell -flattenBus -excludeCellInst "$excludeCellInstList" -excludeTopCellPGPort $vars(exlude_pg_list)  $dsn_gate_dir/[dbgDesignName].lvs.${view_name}.vg.gz -flattenBus
			set lvs_netlist_file "$dsn_gate_dir/[dbgDesignName].lvs.${view_name}.vg.gz"
			###fp exprot for ice
			saveFPlan $dsn_def_dir/[dbgDesignName].${view_name}.fp
			set fp_file "$dsn_def_dir/[dbgDesignName].${view_name}.fp"
			##def 
			defOut -floorplan -netlist -routing  $dsn_def_dir/[dbgDesignName].${view_name}.def.gz
			set def_file "$dsn_def_dir/[dbgDesignName].${view_name}.def.gz"
			##setStreamOutMode -setting
			setStreamOutMode -reset
			setStreamOutMode \
				-labelAllPinShape true \
				-virtualConnection false
			streamOut -mapFile $vars(gds_layer_map) -libName [dbgDesignName] -structureName [dbgDesignName] -stripes 1 -units 1000 -mode ALL -dieAreaAsBoundary $dsn_gds_dir/[dbgDesignName].pr.${view_name}.gds.gz
			if {$mergegds} {
				streamOut $dsn_gds_dir/[dbgDesignName].mergeblock.${view_name}.gds.gz \
				-merge $vars(macro_gds) -mapFile $vars(gds_layer_map) -libName [dbgDesignName] \
                                -structureName [dbgDesignName] -stripes 1 -units 1000 \
                                -mode ALL -dieAreaAsBoundary
				set merge_gds_file $dsn_gds_dir/[dbgDesignName].mergeblock.${view_name}.gds.gz"
				streamOut $dsn_gds_dir/[dbgDesignName].mergeblock.${view_name}.gds.gz \
				-merge $vars(macro_gds_cpu_ddr_modem2) -mapFile $vars(gds_layer_map) -libName [dbgDesignName] \
                                -structureName [dbgDesignName] -stripes 1 -units 1000 \
                                -mode ALL -dieAreaAsBoundary
			}
			set pr_gds_file "$dsn_gds_dir/[dbgDesignName].pr.${view_name}.gds.gz"
			##save edi data
            #if { $vars(library) == "TSMC22ULL" } {
            #    deselectAll
            #    editSelectVia -subclass m1_m2_pg_via
            #    editDelete -selected
            #    deselectAll
            #    # editPowerVia -delete_vias 1 -uda m1_m2_pg_via -top_layer M2 -bottom_layer M1
            #} else {
            #}
			saveDesign $dsn_db_dir/[dbgDesignName].${view_name}.enc -def
			set db_file "$dsn_db_dir/[dbgDesignName].${view_name}.enc"
			## gsc file for IR analysis
			if {[info exists vars(lp_mode)] && $vars(lp_mode) == ""} {
				set file [open $dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc w]
				set file1 [open $dsn_pwr_dir/gsc/[dbgDesignName].lp.${view_name}.gsc w]
				set lpnet ""
				foreach_in_collection instCol [get_cell -hier * -filter "is_memory_cell == true"] {
					set inst [get_object_name $instCol]
					puts $file "$inst HIGH"
					set PD [getInstPowerDomain $inst]
					if {[dbget [dbGetPowerDomainByName $PD].isDefault]} {
						continue
					} else {
						puts $file1 "$inst HIGH"
						set pn [dbget [lindex [dbget -p1 [dbGetInstByName $inst].pgTermNets.isPwr 1] 0].name]
						if {[lsearch $lpnet $pn] == -1 } {
							set lpnet "$pn"
						}
					}
				}
				foreach n $lpnet {
					puts $file1 "* $n POWERUP"
				}
				close $file
				close $file1
				set ir_gsc_file "$dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc"	
				set lp_gsc_file "$dsn_pwr_dir/gsc/[dbgDesignName].lp.${view_name}.gsc"	
			} else {
				set file [open $dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc w]
				foreach_in_collection instCol [get_cell -hier * -filter "is_memory_cell == true"] {
					set inst [get_object_name $instCol]
					puts $file "$inst HIGH"

				}
				close $file
				set ir_gsc_file "$dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc"	
			}

			####pa source loaction
			set f_name_w "$dsn_pwr_dir/ploc/[dbgDesignName].${view_name}.ploc"
			set file_w [open $f_name_w w]
			if {[dbGet top.bumps] == "0x0"} {
				foreach pn $pwr_net_name {
					create_power_pads -clear
					create_power_pads -net $pn -auto_fetch -vsrc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp" -display
				}
				foreach gn $gnd_net_name {
					create_power_pads -clear
					create_power_pads -net $gn -auto_fetch -vsrc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp" -display
				}
				foreach pn $pwr_net_name {
					set file_($pn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp r]
					while { [gets $file_($pn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line POWER"
						}
					}
					close $file_($pn)
				}
				foreach gn $gnd_net_name {
					set file_($gn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp r]
					while { [gets $file_($gn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line GROUND"
						}
					}
					close $file_($gn)
				}
			} else {
				foreach pn $pwr_net_name {
					set file_($pn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp w]
					puts $file_($pn) "*vsrc_name 	x	y layer_name"
					set i 1
					foreach bp [dbGet top.bumps] {
						set x [lindex [lindex [dbget ${bp}.pt] 0] 0]
						set y [lindex [lindex [dbget ${bp}.pt] 0] 1]
						set w [lindex [lindex [dbget ${bp}.cell.size] 0] 0]
						set bump_net [lindex [dbget ${bp}.net.name] 0]
						set bump_layer [dbLefLayerName [lindex [dbget ${bp}.cell.terms.layer] 0]]
						set bump_locx [expr $x + $w/2]
						set bump_locy [expr $y + $w/2]
						if {$bump_net == $pn} {
							puts $file_($pn) "${pn}vsrc${i} $bump_locx $bump_locy $bump_layer"
							incr i
						}
					}
					close $file_($pn)
				}
				foreach gn $gnd_net_name {
					set file_($gn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp w]
					puts $file_($gn) "*vsrc_name 	x	y layer_name"
					set i 1
					foreach bp [dbGet top.bumps] {
						set x [lindex [lindex [dbget ${bp}.pt] 0] 0]
						set y [lindex [lindex [dbget ${bp}.pt] 0] 1]
						set w [lindex [lindex [dbget ${bp}.cell.size] 0] 0]
						set bump_net [lindex [dbget ${bp}.net.name] 0]
						set bump_layer [dbLefLayerName [lindex [dbget ${bp}.cell.terms.layer] 0]]
						set bump_locx [expr $x + $w/2]
						set bump_locy [expr $y + $w/2]
						if {$bump_net == $gn} {
							puts $file_($gn) "${gn}vsrc${i} $bump_locx $bump_locy $bump_layer"
							incr i
						}
					}
					close $file_($gn)
				}
				foreach pn $pwr_net_name {
					set file_($pn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp r]
					while { [gets $file_($pn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line POWER"
						}
					}
					close $file_($pn)
				}
				foreach gn $gnd_net_name {
					set file_($gn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp r]
					while { [gets $file_($gn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line GROUND"
						}
					}
					close $file_($gn)
				}
			}
			close $file_w
			
			set rhwk_pg_loc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${view_name}.ploc"
			set eps_power_loc_file ""
			foreach pn $pwr_net_name {
				lappend eps_power_loc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp"
			}
			set eps_ground_loc_file ""
			foreach gn $gnd_net_name {
				lappend eps_ground_loc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp"
			}
		} elseif {$type_name == "pa"} {
			##delete empty module
			deleteDanglingPort
			deleteEmptyModule
			##verilog 
			saveNetlist $dsn_gate_dir/[dbgDesignName].pr.${view_name}.vg.gz
			set netlist_file "$dsn_gate_dir/[dbgDesignName].pr.${view_name}.vg.gz"
			##def 
			defOut -floorplan -netlist -routing  $dsn_def_dir/[dbgDesignName].${view_name}.def.gz
			set def_file "$dsn_def_dir/[dbgDesignName].${view_name}.def.gz"
			##save edi data
            if { $vars(library) == "TSMC22ULL" } {
                editPowerVia -delete_vias 1 -uda m1_m2_pg_via -top_layer M2 -bottom_layer M1
            } else {
            }
			saveDesign $dsn_db_dir/[dbgDesignName].${view_name}.enc -def
			set db_file "$dsn_db_dir/[dbgDesignName].${view_name}.enc"
			## gsc file for IR analysis
			if {[info exists vars(lp_mode)] && $vars(lp_mode) == ""} {
				set file [open $dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc w]
				set file1 [open $dsn_pwr_dir/gsc/[dbgDesignName].lp.${view_name}.gsc w]
				set lpnet ""
				foreach_in_collection instCol [get_cell -hier * -filter "is_memory_cell == true"] {
					set inst [get_object_name $instCol]
					puts $file "$inst HIGH"
					set PD [getInstPowerDomain $inst]
					if {[dbget [dbGetPowerDomainByName $PD].isDefault]} {
						continue
					} else {
						puts $file1 "$inst HIGH"
						puts pn [dbget [lindex [dbget -p1 [dbGetInstByName $inst].pgTermNets.isPwr 1] 0].name]
						if {[lsearch $lpnet $pn] == -1 } {
							set lpnet "$pn"
						}
					}
				}
				foreach n $lpnet {
					puts $file1 "* $n POWERUP"
				}
				close $file
				clock $file1
				set ir_gsc_file "$dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc"	
				set lp_gsc_file "$dsn_pwr_dir/gsc/[dbgDesignName].lp.${view_name}.gsc"	
			} else {
				set file [open $dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc w]
				foreach_in_collection instCol [get_cell -hier * -filter "is_memory_cell == true"] {
					set inst [get_object_name $instCol]
					puts $file "$inst HIGH"

				}
				close $file
				set ir_gsc_file "$dsn_pwr_dir/gsc/[dbgDesignName].ir.${view_name}.gsc"	
			}

			####pa source loaction
			set f_name_w "$dsn_pwr_dir/ploc/[dbgDesignName].${view_name}.ploc"
			set file_w [open $f_name_w w]
			if {[dbGet top.bumps] == "0x0"} {
				foreach pn $pwr_net_name {
					create_power_pads -clear
				puts "aa"
					create_power_pads -net $pn -auto_fetch -vsrc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp" -display
				}
				foreach gn $gnd_net_name {
					create_power_pads -clear
					create_power_pads -net $gn -auto_fetch -vsrc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp" -display
				}
				foreach pn $pwr_net_name {
					set file_($pn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp r]
					while { [gets $file_($pn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line POWER"
						}
					}
					close $file_($pn)
				}
				foreach gn $gnd_net_name {
					set file_($gn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp r]
					while { [gets $file_($gn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line GROUND"
						}
					}
					close $file_($gn)
				}
			} else {
				foreach pn $pwr_net_name {
					set file_($pn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp w]
					puts $file_($pn) "*vsrc_name 	x	y layer_name"
					set i 1
					foreach bp [dbGet top.bumps] {
						set x [lindex [lindex [dbget ${bp}.pt] 0] 0]
						set y [lindex [lindex [dbget ${bp}.pt] 0] 1]
						set w [lindex [lindex [dbget ${bp}.cell.size] 0] 0]
						set bump_net [lindex [dbget ${bp}.net.name] 0]
						set bump_layer [dbLefLayerName [lindex [dbget ${bp}.cell.terms.layer] 0]]
						set bump_locx [expr $x + $w/2]
						set bump_locy [expr $y + $w/2]
						if {$bump_net == $pn} {
							puts $file_($pn) "${pn}vsrc${i} $bump_locx $bump_locy $bump_layer"
							incr i
						}
					}
					close $file_($pn)
				}
				foreach gn $gnd_net_name {
					set file_($gn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp w]
					puts $file_($gn) "*vsrc_name 	x	y layer_name"
					set i 1
					foreach bp [dbGet top.bumps] {
						set x [lindex [lindex [dbget ${bp}.pt] 0] 0]
						set y [lindex [lindex [dbget ${bp}.pt] 0] 1]
						set w [lindex [lindex [dbget ${bp}.cell.size] 0] 0]
						set bump_net [lindex [dbget ${bp}.net.name] 0]
						set bump_layer [dbLefLayerName [lindex [dbget ${bp}.cell.terms.layer] 0]]
						set bump_locx [expr $x + $w/2]
						set bump_locy [expr $y + $w/2]
						if {$bump_net == $gn} {
							puts $file_($gn) "${gn}vsrc${i} $bump_locx $bump_locy $bump_layer"
							incr i
						}
					}
					close $file_($gn)
				}
				foreach pn $pwr_net_name {
					set file_($pn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp r]
					while { [gets $file_($pn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line POWER"
						}
					}
					close $file_($pn)
				}
				foreach gn $gnd_net_name {
					set file_($gn) [open $dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp r]
					while { [gets $file_($gn) line] !="-1" } {
						if { [regexp {layer_name} $line temp1] ==1 } {
							puts $file_w " "
						} else {
							puts $file_w "$line GROUND"
						}
					}
					close $file_($gn)
				}
			}
			close $file_w
			
			set rhwk_pg_loc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${view_name}.ploc"
			set eps_power_loc_file ""
			foreach pn $pwr_net_name {
				lappend eps_power_loc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${pn}.${view_name}.pp"
			}
			set eps_ground_loc_file ""
			foreach gn $gnd_net_name {
				lappend eps_ground_loc_file "$dsn_pwr_dir/ploc/[dbgDesignName].${gn}.${view_name}.pp"
			}
		} elseif {$type_name == "pv"} {
			##delete empty module
			deleteDanglingPort
			deleteEmptyModule

			## export dummy cts blk
			set file [open $dsn_gds_dir/[dbgDesignName].ctsdum.${view_name}.tcl w]
			puts $file "set Lnew \[layout create\]"
			puts $file "\$Lnew create cell [dbgDesignName]_CRITICAL_NET"
			puts $file "\$Lnew create layer 31"
			puts $file "\$Lnew create layer 32"
			puts $file "\$Lnew create layer 33"
			puts $file "\$Lnew create layer 34"
			puts $file "\$Lnew create layer 35"
			puts $file "\$Lnew create layer 36"
			puts $file "\$Lnew create layer 37"
			puts $file "\$Lnew create layer 38"
			for { set i 2 } {$i < [expr $vars(max_route_layer) +1] } {incr i 1} {
				deselectAll
				editSelect -use CLOCK -layer $i
				if {$vars(process) < 28 } {
					set extendWidth [expr [dbget [dbGetLayerByName $i].width] * 2]
				} else {
					set extendWidth [expr [dbget [dbGetLayerByName $i].width] * 4]
				} 
				set box_list [dbget selected.box]
				foreach box $box_list {
					set lox1 [expr [lindex $box 0] - $extendWidth]
					set loy1 [expr [lindex $box 1] - $extendWidth]
					set lox2 [expr [lindex $box 2] - $extendWidth]
					set loy2 [expr [lindex $box 3] - $extendWidth]
					set lox1_u [expr int ( $lox1 *1000)]
					set loy1_u [expr int ( $loy1 *1000)]
					set lox2_u [expr int ( $lox2 *1000)]
					set loy2_u [expr int ( $loy2 *1000)]

					if {$i == $vars(max_route_layer) } {
							puts $file "\$Lnew create polygon [dbgDesignName]_CRITICAL_NET [expr $i + 30] $lox1_u $loy1_u $lox2_u $loy1_u $lox2_u $loy2_u $lox1_u $loy2_u"
					} else {
							puts $file "\$Lnew create polygon [dbgDesignName]_CRITICAL_NET [expr $i + 30] $lox1_u $loy1_u $lox2_u $loy1_u $lox2_u $loy2_u $lox1_u $loy2_u"
					}
				}
			}
			deselectAll
			puts $file "\$Lnew gdsout $ctsexcl_gds_dir/[dbgDesignName].ctsdumyexlude.${view_name}.gds.gz"
			close $file
			set dum_excl_file "$dsn_gds_dir/[dbgDesignName].ctsdum.${view_name}.tcl"
			
			##physcial verilog netlist export
			#serach exculde cell list
			set excludeCellInstList ""
#			foreach cellName [dbGet -u head.allCells.physInsts.cell.name] {
#				if {[regexp "CUT" $cellName] || [regexp "PAD_WIN" $cellName] } {
#					lappend excludeCellInstList $cellName
#				} else {
#					if {[dbGet [dbGet -p1 head.allCells.isTimeDefined 1].name $cellName] =="0x0" } {
#						lappend excludeCellInstList $cellName
#					}
#				}
#			}
			foreach cell $vars(exclude_cells) {
				if { [dbGet head.allCells.name $cell] != "0x0" } {
                    foreach c [dbGet head.allCells.name $cell] {
						lappend excludeCellInstList $cell
					}
				}

			}
			saveNetlist -phys -flattenBus -excludeLeafCell -excludeCellInst "$excludeCellInstList" -excludeTopCellPGPort $vars(exlude_pg_list)  $dsn_gate_dir/[dbgDesignName].lvs.${view_name}.vg.gz
			set lvs_netlist_file "$dsn_gate_dir/[dbgDesignName].lvs.${view_name}.vg.gz"

			##setStreamOutMode -setting
			setStreamOutMode -reset
			setStreamOutMode \
				-labelAllPinShape true \
				-virtualConnection false
			streamOut $dsn_gds_dir/[dbgDesignName].pr.${view_name}.gds.gz \
				-mapFile $vars(gds_layer_map) -libName [dbgDesignName] \
				-structureName [dbgDesignName] -stripes 1 -units 1000 \
				-mode ALL -dieAreaAsBoundary
			if {$mergegds} {
				streamOut $dsn_gds_dir/[dbgDesignName].mergecell.${view_name}.gds.gz \
				-merge $vars(GDS_LIBS) -mapFile $vars(gds_layer_map) -libName [dbgDesignName] \
                                -structureName [dbgDesignName] -stripes 1 -units 1000 \
                                -mode ALL -dieAreaAsBoundary
				set merge_gds_file $dsn_gds_dir/[dbgDesignName].mergecell.${view_name}.gds.gz"
			}
			set pr_gds_file "$dsn_gds_dir/[dbgDesignName].pr.${view_name}.gds.gz"
			##save edi data
            if { $vars(library) == "TSMC22ULL" } {
                editPowerVia -delete_vias 1 -uda m1_m2_pg_via -top_layer M2 -bottom_layer M1
            } else {
            }
			saveDesign $dsn_db_dir/[dbgDesignName].${view_name}.enc -def
			set db_file "$dsn_db_dir/[dbgDesignName].${view_name}.enc"
		} elseif {$type_name == "sta" } {
			##delete empty module
			deleteDanglingPort
			deleteEmptyModule

			##verilog 
			saveNetlist $dsn_gate_dir/[dbgDesignName].pr.${view_name}.vg.gz
			saveNetlist -excludeLeafCell -flattenBus -includePowerGround -excludeTopCellPGPort $vars(exlude_pg_list) -includePhysicalCell $vars(pg_physical_cells) $dsn_gate_dir/[dbgDesignName].pg.${view_name}.vg.gz
			set netlist_file "$dsn_gate_dir/[dbgDesignName].pr.${view_name}.vg.gz"
			set pg_netlist_file "$dsn_gate_dir/[dbgDesignName].pg.${view_name}.vg.gz"
			
			###fp exprot for ice
			saveFPlan $dsn_def_dir/[dbgDesignName].${view_name}.fp
			set fp_file "$dsn_def_dir/[dbgDesignName].${view_name}.fp"
			##def 
			defOut -floorplan -netlist -routing  $dsn_def_dir/[dbgDesignName].${view_name}.def.gz
			set def_file "$dsn_def_dir/[dbgDesignName].${view_name}.def.gz"
			##save edi data
            if { $vars(library) == "TSMC22ULL" } {
                editPowerVia -delete_vias 1 -uda m1_m2_pg_via -top_layer M2 -bottom_layer M1
            } else {
            }
			saveDesign $dsn_db_dir/[dbgDesignName].${view_name}.enc -def
			set db_file "$dsn_db_dir/[dbgDesignName].${view_name}.enc"
		}
		## release mode link data to dsn
		if {$release} {
			if {$dum_excl_file !=""} {exec chmod 555 -R $dum_excl_file; exec ln -sf $dum_excl_file $base_path/../../dsn/gds}
			if {$netlist_file !=""} {exec chmod 555 -R $netlist_file; exec ln -sf $netlist_file $base_path/../../dsn/gate}
			if {$pg_netlist_file !=""} {exec chmod 555 -R $pg_netlist_file; exec ln -sf $pg_netlist_file $base_path/../../dsn/gate}
			if {$lvs_netlist_file !=""} {exec chmod 555 -R $lvs_netlist_file; exec ln -sf $lvs_netlist_file $base_path/../../dsn/gate}
			if {$fp_file !=""} {exec chmod 555 -R $fp_file; exec ln -sf $fp_file $base_path/../../dsn/def}
			if {$fp_file !=""} {exec chmod 555 -R ${fp_file}.spr; exec ln -sf ${fp_file}.spr $base_path/../../dsn/def}
			if {[file exists ${fp_file}.sftr]} { exec chmod 555 -R ${fp_file}.sftr; exec ln -sf ${fp_file}.sftr $base_path/../../dsn/def}
			if {$def_file !=""} {exec chmod 555 -R $def_file; exec ln -sf $def_file $base_path/../../dsn/def}
			if {$def_for_ice !=""} {exec chmod 555 -R $def_for_ice; exec ln -sf $def_for_ice $base_path/../../dsn/def}
			if {$pr_gds_file !=""} {exec chmod 555 -R $pr_gds_file; exec ln -sf $pr_gds_file $base_path/../../dsn/gds}
			if {$merge_gds_file !=""} {exec chmod 555 -R $merge_gds_file; exec ln -sf $merge_gds_file $base_path/../../dsn/gds}
			if {$db_file !=""} {exec chmod 555 -R $db_file}
			if {$db_file !=""} {exec chmod 555 -R ${db_file}.dat}
			if {$rhwk_pg_loc_file !=""} {exec chmod 555 -R $rhwk_pg_loc_file; exec ln -sf $rhwk_pg_loc_file $base_path/../../dsn/pwr/ploc}
			if {$ir_gsc_file !=""} {exec chmod 555 -R $ir_gsc_file; exec ln -sf $ir_gsc_file $base_path/../../dsn/pwr/gsc}
			if {$lp_gsc_file !=""} {exec chmod 555 -R $lp_gsc_file; exec ln -sf $lp_gsc_file $base_path/../../dsn/pwr/gsc}
			if {$eps_power_loc_file !=""} {
				foreach ff $eps_power_loc_file {
					exec chmod 555 -R $ff; exec ln -sf $ff $base_path/../../dsn/pwr/ploc
				}
			}
			if {$eps_ground_loc_file !=""} {
				foreach ff $eps_ground_loc_file {
					exec chmod 555 -R $ff; exec ln -sf $ff $base_path/../../dsn/pwr/ploc
				}
			}
			set release_file [open $base_path/../../dsn/release/$dir_name/[dbgDesignName].${view_name}.releasenote.txt w]
			set release_date [exec date]
			puts $release_file "#########################################################################"
			puts $release_file "Design:[dbgDesignName]"
			puts $release_file "Release date: [exec date]"
			puts $release_file "#########################################################################"
			puts $release_file "dum_excl_file : $dum_excl_file"
			puts $release_file "netlist_file: : $netlist_file"
			puts $release_file "pg_netlist_file: : $pg_netlist_file"
			puts $release_file "lvs_netlist_file: : $lvs_netlist_file"
			puts $release_file "floorplan_file: : $fp_file"
			puts $release_file "def_file: : $def_file"
			puts $release_file "def_for_ice: : $def_for_ice"
			puts $release_file "pr_gds_file: : $pr_gds_file"
			puts $release_file "merge_gds_file: : $merge_gds_file"
			puts $release_file "database_file: : $db_file"
			puts $release_file "rehawk_pgloc_file: : $rhwk_pg_loc_file"
			puts $release_file "eps_power_loc_file: : $eps_power_loc_file"
			puts $release_file "eps_ground_loc_file: : $eps_ground_loc_file"
			close $release_file
			exec chmod 555 -R $base_path/../../dsn/release/$dir_name/[dbgDesignName].${view_name}.releasenote.txt
		}
	}
}
proc userCreatePlaceBlockage {num} {
	set size_x [expr 1 * [lindex [join [dbget top.fPlan.coreSite.size]] 1]]
	set size_y [lindex [join [dbget top.fPlan.coreSite.size]] 1]

	set fp_shapes [dbShape [dbGet top.fplan.boxes] SIZE 5 SIZE -5 -output polygon]
#	set inner_fp_shapes [dbShape $fp_shapes SIZEY -$size_y  -output polygon]
#	set inner_fp_shapes [dbShape $inner_fp_shapes SIZEX -$size_x  -output polygon]
	set inner_fp_shapes [dbShape $fp_shapes SIZEY -${num}  -output polygon]
	set inner_fp_shapes [dbShape $inner_fp_shapes SIZEX -${num} -output polygon]
	set inner_block_boxes [dbShape $fp_shapes ANDNOT $inner_fp_shapes -output rect]
	foreach box $inner_block_boxes {
                set x1 [lindex $box 0]
                set y1 [lindex $box 1]
                set x2 [lindex $box 2]
                set y2 [lindex $box 3]
                createPlaceBlockage -box "$x1 $y1 $x2 $y2" -name bundaryBLK
        }
}
proc userCreateRouteBlk {bottom_layer top_layer} {
	set size_x [expr 2 * [lindex [join [dbget top.fPlan.coreSite.size] 1] 0]]
#	set size_y [lindex [join [dbget top.fPlan.coreSite.size]] 1]
	set size_y [expr 2 * [lindex [join [dbget top.fPlan.coreSite.size] 1] 0]]

	set fp_shapes [dbShape [dbGet top.fplan.boxes] SIZE 5 SIZE -5 -output polygon]
#	set inner_fp_shapes [dbShape $fp_shapes SIZEY -$size_y  -output polygon]
#	set inner_fp_shapes [dbShape $inner_fp_shapes SIZEX -$size_x  -output polygon]
	set inner_fp_shapes [dbShape $fp_shapes SIZEY -${size_y}  -output polygon]
	set inner_fp_shapes [dbShape $inner_fp_shapes SIZEX -${size_x} -output polygon]
	set inner_block_boxes [dbShape $fp_shapes ANDNOT $inner_fp_shapes -output rect]
	foreach box $inner_block_boxes {
                set x1 [lindex $box 0]
                set y1 [lindex $box 1]
                set x2 [lindex $box 2]
                set y2 [lindex $box 3]
		for { set i  $bottom_layer } { $i <= $top_layer} { incr i 1} {
                createRouteBlk -box "$x1 $y1 $x2 $y2" -name bundaryRLK -layer M${i}
        	}
	}
}
proc userCreateIOPLK {xhalo yhalo} {
	set io_inst [get_cell *_iobuffer]
	setInstancePlacementStatus -name *_iobuffer -status fixed
	foreach_in_collection inst $io_inst { 
		deselectAll
		selectInst $inst
		set x1 [expr [dbGet selected.box_llx] - $xhalo]
		set y1 [expr [dbGet selected.box_lly] - $yhalo]
		set x2 [expr [dbGet selected.box_urx] + $xhalo]
		set y2 [expr [dbGet selected.box_ury] + $yhalo]
                createPlaceBlockage -box "$x1 $y1 $x2 $y2" -name iocell_BLK
        }
	deselectAll
}
proc userCreatePgOverClamp {xhalo yhalo pwr_net gnd_net} {
#	deselectAll
	addHaloToBlock -cell VDD1CE $xhalo $yhalo $xhalo $yhalo
	addHaloToBlock -cell VDD2CEN $xhalo $yhalo $xhalo $yhalo
#	globalNetConnect VDD -pin VDD11_CP -type pgpin -override
#	globalNetConnect VSS -pin VSS_CP -type pgpin -override
#	selectInstByCellName VDD1CE
#	selectInstByCellName VDD2CEN 
	set clamp_inst [dbGet selected.name]
	deselectAll
	foreach inst $clamp_inst {
		deselectAll
		selectInst $inst 
		set ori [dbGet selected.orient]
		set cell_name [dbGet selected.cell.name]
		set loc_x [dbGet selected.pt_x]
		set loc_y [dbGet selected.pt_y]
		setAddStripeMode -skip_via_on_pin {pad cover standardcell physicalpin block} -skip_via_on_wire_shape {stripe}
		puts "$ori"
		 if { $ori == "R0" || $ori == "MY" || $ori == "MX" || $ori == "R180"  } { 
			set box_list [dbGet [dbGet -p2 [dbGet -p2 selected.pgInstTerms.net.name $pwr_net].term.pins.layerShapeShapes.layer.name M3].shapes.rect]
			puts "$box_list"
			foreach box $box_list {
                		set llx_0 [lindex $box 0]
             			set lly_0 [lindex $box 1]
       				set urx_0 [lindex $box 2]
         		        set ury_0 [lindex $box 3]
				set global_cor [dbTransform -inst $inst -localPt "$llx_0 $lly_0 $urx_0 $ury_0"]
                		set llx [lindex $global_cor 0]
             			set lly [lindex $global_cor 1]
       				set urx [lindex $global_cor 2]
         		        set ury [lindex $global_cor 3]
				puts "$llx $lly $urx $ury"
				set width [expr  int([expr ($ury-$lly) *100])/100.0]
				
				### note 15 num,please modfiy it if clamp change
				if { [expr $urx -$llx] > 15 } {
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M4 -block_ring_top_layer_limit M4 -padcore_ring_top_layer_limit M4 -padcore_ring_bottom_layer_limit M4 -direction horizontal -layer M4 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly  [expr $urx + 10 ] $ury" -start_from left
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M5 -block_ring_top_layer_limit M5 -padcore_ring_top_layer_limit M5 -padcore_ring_bottom_layer_limit M5 -direction horizontal -layer M5 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly  [expr $urx + 10 ] $ury" -start_from left
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M6 -block_ring_top_layer_limit M6 -padcore_ring_top_layer_limit M6 -padcore_ring_bottom_layer_limit M6 -direction horizontal -layer M6 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly  [expr $urx + 10 ] $ury" -start_from left
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M7 -block_ring_top_layer_limit M7 -padcore_ring_top_layer_limit M7 -padcore_ring_bottom_layer_limit M7 -direction horizontal -layer M7 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly  [expr $urx + 10 ] $ury" -start_from left
				}
			}
			set box_list [dbGet [dbGet -p2 [dbGet -p2 selected.pgInstTerms.net.name $gnd_net].term.pins.layerShapeShapes.layer.name M3].shapes.rect]
			foreach box $box_list {
                		set llx_0 [lindex $box 0]
             			set lly_0 [lindex $box 1]
       				set urx_0 [lindex $box 2]
         		        set ury_0 [lindex $box 3]
				set global_cor [dbTransform -inst $inst -localPt "$llx_0 $lly_0 $urx_0 $ury_0"]
                		set llx [lindex $global_cor 0]
             			set lly [lindex $global_cor 1]
       				set urx [lindex $global_cor 2]
         		        set ury [lindex $global_cor 3]
				set width [expr  int([expr ($ury-$lly) *100])/100.0]
				### note 15 num,please modfiy it if clamp change
				if { [expr $urx -$llx] > 15 } {
					addStripe -start_offset 0  -width $width -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M4 -block_ring_top_layer_limit M4 -padcore_ring_top_layer_limit M4 -padcore_ring_bottom_layer_limit M4 -direction horizontal -layer M4 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly [expr $urx + 10 ] $ury" -start_from left
					addStripe -start_offset 0  -width $width -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M5 -block_ring_top_layer_limit M5 -padcore_ring_top_layer_limit M5 -padcore_ring_bottom_layer_limit M5 -direction horizontal -layer M5 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly [expr $urx + 10 ] $ury" -start_from left
					addStripe -start_offset 0  -width $width -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M6 -block_ring_top_layer_limit M6 -padcore_ring_top_layer_limit M6 -padcore_ring_bottom_layer_limit M6 -direction horizontal -layer M6 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly [expr $urx + 10 ] $ury" -start_from left
					addStripe -start_offset 0  -width $width -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M7 -block_ring_top_layer_limit M7 -padcore_ring_top_layer_limit M7 -padcore_ring_bottom_layer_limit M7 -direction horizontal -layer M7 -set_to_set_distance 6000 -area "[expr $llx - 10 ] $lly [expr $urx + 10 ] $ury" -start_from left
				}
			}
		} else {
			set box_list [dbGet [dbGet -p2 [dbGet -p2 selected.pgInstTerms.net.name $pwr_net].term.pins.layerShapeShapes.layer.name M3].shapes.rect]
			foreach box $box_list {
                		set llx_0 [lindex $box 0]
             			set lly_0 [lindex $box 1]
       				set urx_0 [lindex $box 2]
         		        set ury_0 [lindex $box 3]
				set global_cor [dbTransform -inst $inst -localPt "$llx_0 $lly_0 $urx_0 $ury_0"]
                		set llx [lindex $global_cor 0]
             			set lly [lindex $global_cor 1]
       				set urx [lindex $global_cor 2]
         		        set ury [lindex $global_cor 3]
				set width [expr  int([expr ($urx-$llx) *100])/100.0]
				### note 15 num,please modfiy it if clamp change
				if { [expr $ury -$lly] > 15 } {
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M4 -block_ring_top_layer_limit M4 -padcore_ring_top_layer_limit M4 -padcore_ring_bottom_layer_limit M4  -direction vertical -layer M4 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M5 -block_ring_top_layer_limit M5 -padcore_ring_top_layer_limit M5 -padcore_ring_bottom_layer_limit M5  -direction vertical -layer M5 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M6 -block_ring_top_layer_limit M6 -padcore_ring_top_layer_limit M6 -padcore_ring_bottom_layer_limit M6  -direction vertical -layer M6 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
					addStripe -start_offset 0 -width $width -nets $pwr_net -uda clamp_power -block_ring_bottom_layer_limit M7 -block_ring_top_layer_limit M7 -padcore_ring_top_layer_limit M7 -padcore_ring_bottom_layer_limit M7  -direction vertical -layer M7 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
				}
			}
			set box_list [dbGet [dbGet -p2 [dbGet -p2 selected.pgInstTerms.net.name $gnd_net].term.pins.layerShapeShapes.layer.name M3].shapes.rect]
			foreach box $box_list {
                		set llx_0 [lindex $box 0]
             			set lly_0 [lindex $box 1]
       				set urx_0 [lindex $box 2]
         		        set ury_0 [lindex $box 3]
				set global_cor [dbTransform -inst $inst -localPt "$llx_0 $lly_0 $urx_0 $ury_0"]
                		set llx [lindex $global_cor 0]
             			set lly [lindex $global_cor 1]
       				set urx [lindex $global_cor 2]
         		        set ury [lindex $global_cor 3]
				set width [expr  int([expr ($urx-$llx) *100])/100.0]
				### note 15 num,please modfiy it if clamp change
				if { [expr $ury -$lly] > 15 } {
					addStripe -start_offset 0  -width $width  -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M4 -block_ring_top_layer_limit M4 -padcore_ring_top_layer_limit M4 -padcore_ring_bottom_layer_limit M4  -direction vertical -layer M4 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
					addStripe -start_offset 0  -width $width  -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M5 -block_ring_top_layer_limit M5 -padcore_ring_top_layer_limit M5 -padcore_ring_bottom_layer_limit M5  -direction vertical -layer M5 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
					addStripe -start_offset 0  -width $width  -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M6 -block_ring_top_layer_limit M6 -padcore_ring_top_layer_limit M6 -padcore_ring_bottom_layer_limit M6  -direction vertical -layer M6 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
					addStripe -start_offset 0  -width $width  -nets $gnd_net -uda clamp_power -block_ring_bottom_layer_limit M7 -block_ring_top_layer_limit M7 -padcore_ring_top_layer_limit M7 -padcore_ring_bottom_layer_limit M7  -direction vertical -layer M7 -set_to_set_distance 6000 -area "$llx [expr $lly - 10] $urx [expr $ury +10 ]" -start_from bottom
				}
			}
		}
	}
	deselectAll
	editSelect -subclass clamp_power
	editPowerVia -between_selected_wires 1 -via_scale_height 80 -via_scale_width 80  -split_vias 1 -top_layer M8 -bottom_layer M3 -uda clamp_via -orthogonal_only false -add_vias 1 -via_using_exact_crossover_size 1
	deselectAll
#	selectInstByCellName VDD1CE
#	selectInstByCellName VDD2CEN 
#	editPowerVia -selected_blocks 1 -via_scale_height 80 -via_scale_width 80 -split_vias 1 -top_layer M4 -bottom_layer M3 -uda clamp_via -orthogonal_only false -add_vias 1 -via_using_exact_crossover_size 1
#	set clamp_inst [dbGet selected.name]
#	deselectAll
	foreach inst $clamp_inst {
		deselectAll
		selectInst $inst 
		editPowerVia -selected_blocks 1 -via_scale_height 80 -via_scale_width 80 -split_vias 1 -top_layer M4 -bottom_layer M3 -uda clamp_via -orthogonal_only false -add_vias 1 -via_using_exact_crossover_size 1
		set llx [dbGet selected.phaloBox_llx]
		set lly [dbGet selected.phaloBox_lly]
		set urx [dbGet selected.phaloBox_urx]
		set ury [dbGet selected.phaloBox_ury]
		createRouteBlk -box "$llx $lly $urx $ury" -exceptpgnet -name clamp_routblk -layer "M1 M2 M3 M4 M5 M6 M7"
	}
		
	deselectAll

	
}
proc userCreateOCCDBLK {} {
	deselectAll
	addHaloToBlock -cell OCCD_6X6 2.5 2.5 2.5 2.5
	addHaloToBlock -cell OCOVL_BiB 2.5 2.5 2.5 2.5
	selectInstByCellName OCCD_6X6
	selectInstByCellName OCOVL_BiB
	set OCCD_inst [dbGet selected.name]
	deselectAll
	foreach inst $OCCD_inst { 
		selectInst $inst
		set llx [dbGet selected.phaloBox_llx]
		set lly [dbGet selected.phaloBox_lly]
		set urx [dbGet selected.phaloBox_urx]
		set ury [dbGet selected.phaloBox_ury]
		createRouteBlk -box "$llx $lly $urx $ury" -name occd_routblk -layer "M1 M2 "
		deselectAll
        }
}


proc summarizeDesign {file} {
	global vars
	set area_all 0
	
	foreach area [dbGet  top.insts.area ] {
		set area_all [expr $area_all + $area]
	}

	#total block area
	set fp_area  [dbGet top.FPlan.area ]
	
	#memory boundary placeblockage area
	set bndy_pblk_area 0
	set bndy_pblk_box ""
	foreach box [dbGet -e [dbGet -p -e top.fplan.pBlkgs.name bundaryBLK].boxes ] {
		set bndy_pblk_box [dbShape $bndy_pblk_box OR $box]
	}
	foreach box $bndy_pblk_box {
		set bndy_pblk_area [expr [dbShape $box -output area]+$bndy_pblk_area]
	}

	#memory and memory halo area
	set mem_halo_area 0
	set mem_halo_box ""
	foreach box [dbGet [dbGet -p2 top.insts.cell.subClass block].pHaloBox] {
		set mem_halo_box [dbShape $mem_halo_box OR $box]
	}	
	foreach box $mem_halo_box {
		set mem_halo_area [expr [dbShape $box -output area]+$mem_halo_area]
	}

	#memory and memory halo area and memory channel area
	set mem_halo_channel_area 0
	set mem_halo_channel_box ""
	foreach box [dbShape [dbShape [dbGet [dbGet -p2 top.insts.cell.subClass block].pHaloBox] SIZE 10] SIZE -10] {
		set mem_halo_channel_box [dbShape $mem_halo_channel_box OR $box]
	}	
	foreach box $mem_halo_channel_box {
		set mem_halo_channel_area [expr [dbShape $box -output area]+$mem_halo_channel_area]
	}

	#
	set utlization1 [expr double ($area_all)/$fp_area]
	set utlization2 [expr double ([expr $area_all-$mem_halo_area]/[expr $fp_area-$bndy_pblk_area-$mem_halo_area])]
	set utlization3 [expr double ([expr $area_all-$mem_halo_channel_area]/[expr $fp_area-$bndy_pblk_area-$mem_halo_channel_area])]

	#
	set all_non_physical_cell_num [llength [dbGet [dbGet -p top.insts.isPhysOnly 0].name]]
	
	set f [open ./${file} w]

	puts $f "instance number: $all_non_physical_cell_num\n"
	puts $f "block area: $fp_area\n"
	puts $f "utlization1: area_inst_all/fp_area"
	puts $f "utlization1: $utlization1\n"
	puts $f "utlization2: (area_inst_all-mem_halo_area)/(fp_area-boundary_pblk_area-mem_halo_area)"
	puts $f "utlization2: $utlization2\n"
	puts $f "utlization3: (area_inst_all-mem_halo_channel_area)/(fp_area-boundary_pblk_area-mem_halo_channel_area)"
	puts $f "utlization3: $utlization3\n"
	
	foreach vt_class $vars(rpt_inst_vtclass) {
		if { [regexp -nocase {^TSMC} $vars(library)] > 0 } {
			if { ${vt_class} == "SVT" } {
				set vt_class ""
				set SVT_num [llength [dbGet -e [dbGet -p top.insts.isPhysOnly 0].cell.name *P140${vt_class}]]
				set SVT_ratio [expr double ([llength [dbGet -e [dbGet -p top.insts.isPhysOnly 0].cell.name *P140${vt_class}]])/${all_non_physical_cell_num}]
				puts $f "SVT Cell Count: $SVT_num  of total: $SVT_ratio"
			} else {
				set vt_class_ratio [expr double ([llength [dbGet -e [dbGet -p top.insts.isPhysOnly 0].cell.name *P140${vt_class}]])/${all_non_physical_cell_num}]
				set vt_class_num [llength [dbGet -e [dbGet -p top.insts.isPhysOnly 0].cell.name *P140${vt_class}]]
				puts $f "${vt_class} Cell Count: ${vt_class_num}  of total: ${vt_class_ratio}"
			}
		} elseif { [regexp -nocase {^ARM} $vars(library)] > 0 } {
				set VT_num [llength [dbGet -e [dbGet -p top.insts.isPhysOnly 0].cell.name *${vt_class}*]]
				set vt_class_ratio [expr double ([llength [dbGet -e [dbGet -p top.insts.isPhysOnly 0].cell.name *${vt_class}*]])/${all_non_physical_cell_num}]
				puts $f "${vt_class} Cell Count: ${VT_num}  of total: ${vt_class_ratio}"
		}
	}
	close $f
}

proc userSwapCKTree {args}  {
##userSwapCKTree A9TR50
	global vars
	set file [open $vars(rpt_dir)/[dbgDesignName].$vars(step).SwapCKTree.$vars(view_rpt).rpt w]
	setEcoMode -refinePlace false -updateTiming false
	setEcoMode -honorDontUse false -honorDontTouch false -honorFixedStatus false
	setEcoMode -LEQCheck true
	dbForEachCellNet [dbgTopCell] netPtr {
		if {[dbget ${netPtr}.isClock] || [dbget ${netPtr}.isCTSClock]} {
			dbForEachNetTerm $netPtr termPtr {
				if {[dbGet ${termPtr}.objType] == "term"} {
					continue
				} else {
					set instPtr [dbTermInst $termPtr]
					if {[dbGet ${instPtr}.cell.baseClass] == "block" || [dbGet ${instPtr}.cell.baseClass] == "pad" || [dbGet  ${instPtr}.cell.name  ANTEN*]!="0x0" } {
						continue
					} else {
						set InstName [dbget $instPtr.name]
						set cell [dbget [dbInstCell $instPtr].name]
						if { [sizeof_collection [get_cells -quiet -filter "@is_sequential==true && @is_integrated_clock_gating_cell == false" $InstName]] } {
							continue
						} else { 
							if {[regexp -nocase {^TSMC} $vars(library)]} {
								if { [regexp {P140${args}$} $cell] == 1 } {
									continue
								} else {
									regsub {P140.*$} $cell "P140${args}" new_cell
									set cmd "ecoChangeCell -inst $InstName -cell $new_cell"
									puts $file $cmd
									catch {eval $cmd}
								}
							} elseif {[regexp {^SMIC} $vars(library)] || [regexp {^ARM} $vars(library)]} {
							} else {
								puts "WARNING : No support for $vars(library) now!!"
								break
							}
						}
					}
				}
			}
		}
	}
	close $file
	setEcoMode -reset
}

#check no ck cell
proc userCheckCKTree {args}  {
##userSwapCKTree A9TR50
	global vars
	set file [open $vars(rpt_dir)/[dbgDesignName].$vars(step).CheckCKTree.$vars(view_rpt).rpt w]
	dbForEachCellNet [dbgTopCell] netPtr {
		if {[dbget ${netPtr}.isClock] || [dbget ${netPtr}.isCTSClock]} {
			dbForEachNetTerm $netPtr termPtr {
				if {[dbGet ${termPtr}.objType] == "term"} {
					continue
				} else {
					set instPtr [dbTermInst $termPtr]
					if {[dbGet ${instPtr}.cell.baseClass] == "block" || [dbGet ${instPtr}.cell.baseClass] == "pad" || [dbGet  ${instPtr}.cell.name  ANTEN*]!="0x0" } {
						continue
					} else {
						set InstName [dbget $instPtr.name]
						set cell [dbget [dbInstCell $instPtr].name]
						if { [sizeof_collection [get_cells -quiet -filter "@is_sequential==true && @is_integrated_clock_gating_cell == false" $InstName]] } {
							continue
						} else { 
							if {[regexp -nocase {^TSMC} $vars(library)]} {
								if { [regexp {P140${args}$} $cell] == 1 } {
									continue
								} else {
									puts $file "$InstName $cell"
								}
							} elseif {[regexp {^SMIC} $vars(library)] || [regexp {^ARM} $vars(library)]} {
							} else {
								puts "WARNING : No support for $vars(library) now!!"
								break
							}
						}
					}
				}
			}
		}
	}
	close $file
}

#fix isolation cell
proc userFixIsoPlacement {}  {
	global vars
	foreach iso $vars(iso_cell) {
		foreach iso_inst [dbGet -e [dbGet -p2 -e top.insts.cell.name $iso].name] {
			setInstancePlacementStatus -name $iso_inst -status fixed
		}
	}
}

#fix aon_buffer cell
proc userFixAonBufferPlacement {}  {
	global vars
	foreach gbuf $vars(aonbuffer_cells) {
		foreach gbuf_inst [dbGet -e [dbGet -p2 -e top.insts.cell.name $gbuf].name] {
			setInstancePlacementStatus -name $gbuf_inst -status fixed
		}
	}
}

#fix retention cell
proc userFixRetentionPlacement {}  {
	global vars
	foreach ret_cell $vars(retention_cells) {
		foreach ret_inst [dbGet -e [dbGet -p2 -e top.insts.cell.name $ret_cell].name] {
			setInstancePlacementStatus -name $ret_inst -status fixed
		}
	}
}

#fix level_shifter cell
proc userFixShifterPlacement {}  {
	global vars
	foreach shift_cell $vars(l2hshifter_cells) {
		foreach shift_inst [dbGet -e [dbGet -p2 -e top.insts.cell.name $shift_cell].name] {
			setInstancePlacementStatus -name $shift_inst -status fixed
		}
	}
}

#deal with occ
proc userHandleOcc {} {
    global vars
    set i 0
    foreach hinstPtr [dbGet -u -p top.insts.hInst.name *_occ_*] {
	    set hinst_name [dbGet $hinstPtr.name]
	    set cmd "createInstGroup [lindex [split $hinst_name "/"] end]_$i -softGuide -density 0.4 -ar 0.8 "
	    puts $cmd
        eval $cmd
	    incr i
    }
}
