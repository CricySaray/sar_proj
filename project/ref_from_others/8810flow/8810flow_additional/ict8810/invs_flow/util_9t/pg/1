proc my.pg.delete_all_pwrsh {} {
	foreach pds [dbGet [dbGet top.pds.isAlwaysOn 0 -p].name] {
		deletePowerSwitch -column -powerDomain $pds
	}
}
proc my.fp.block_channel { clx cly {type soft}} {
	deletePlaceBlockage pb4channel_${type}_*
	if [info exist area] { unset area } ;
	foreach mem [dbGet top.insts.cell.subClass block -p2] {
		if [info exist area] {
			set area [dbShape $area OR [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]]
		} else {
			set area [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]
		}
	}
	set i 0
	foreach box [dbShape $area SIZEX -$clx SIZEY -$cly] {
		createPlaceBlockage -box $box -type $type -name pb4channel_${type}_$i ;
		incr i
	}
}
proc my.fp.block_core { clx cly {type soft}} {
	deletePlaceBlockage pb4core_*
	if [info exist area] { unset area } ;
	foreach mem [dbGet top.insts.cell.subClass block -p2] {
		if [info exist area] {
			set area [dbShape $area OR [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]]
		} else {
			set area [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]
		}
	}
	set i 0
	foreach box [dbShape [dbGet top.fplan.boxes] ANDNOT [dbShape $area SIZEX -$clx SIZEY -$cly]] {
		createPlaceBlockage -box $box -type $type -name pb4core_${type}_$i ;
		incr i
	}
}
proc my.fp.block_for_channel_psw { clx cly {type soft}} {
	global vars
	set block_shapes [dbShape [dbget [dbGet top.insts.cell.subClass block -p2].box] -output polygon]
	set boundary_left_cells_shapes [dbShape [dbget [dbGet top.insts.cell.name BOUNDARY_LEFTBWP35P140 -p2].boxes] -output polygon]
	set boundary_left_cells_boxes [dbShape $boundary_left_cells_shapes -output rect]
	## get all domain shapes
	set vars(power_domains) [userGetPowerDomains]
	set vars(GND) [dbPowerDomainGNet [lindex $vars(power_domains) 0]]
	set shut_domain_shapes_all {0 0 0 0}
	foreach domain $vars(power_domains) {
		if {[dbget [dbget top.pds.group.name $domain -p2].isDefault] ==1} {
			set vars(AON_PWR) [dbPowerDomainPNet [dbGetPowerDomainByName $domain]]
		} else {
			deselectAll
			selectObject Group $domain
			set ${domain}_shapes [dbShape [dbget selected.boxes] -output polygon]
			set shut_domain_shapes_all [dbShape [set ${domain}_shapes] OR $shut_domain_shapes_all  -output polygon]
		}
	}
	deselectAll
	set aon_domain_shapes_all [dbShape [dbget top.flan.boxes] ANDNOT $shut_domain_shapes_all -output polygon]
	foreach domain $vars(power_domains) {
		set ${domain}_boxes ""
		if {[dbget [dbget top.pds.group.name $domain -p2].isDefault] ==1} {
			set shape1 $aon_domain_shapes_all
		else {
			set shape1 [set ${domain}_shapes]
		}
		foreach box $boundary_left_cells_boxes {
			set or_poly [dbshape [dbshape [dbshape $box -output polygon] SIZEX 15 -output polygon] OR $shape1 -output polygon]
			set and_poly [dbshape [dbshape [dbshape $box -output polygon] -output polygon] AND $shape1 -output polygon]
			set and_mem_poly [dbshape [dbshape $block_shapes SIZEX 10] AND [dbshape $box -output polygon] -output polygon]
			if {$or_poly != $shape1 && $and_poly != "" && $and_mem_poly != ""} {
				lappend ${domain}_boxes $box
			}
		}
	}
	deletePlaceBlockage pb4channelpsw_*
	if [info exist area] { unset area } ;
	foreach mem [dbGet top.insts.cell.subClass block -p2] {
		if [info exist area] {
			set area [dbShape $area OR [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]]
		} else {
			set area [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]
		}
	}
	set i 0
	set block_boxes [dbShape [dbGet top.fplan.boxes] ANDNOT [dbShape $area SIZEX -$clx SIZEY -$cly]]
	foreach domain $vars(power_domains) {
		set block_boxes [dbShape $block_boxes ANDNOT [dbShape [set ${domain}_boxes] SIZEX 10]]
	}
	foreach box $block_boxes {
		createPlaceBlockage -box $box -type $type -name pb4channelpsw_${type}_$i ;
		incr i
	}
}

proc my.fp.get_channel {clx xly} {
	set mem_list [dbGet top.insts.cell.subClass block -p2]
	foreach mem $mem_list {
		if [info exist area] {
			set area [dbShape $area OR [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]]
		} else {
			set area [dbShape [dbGet $mem.box] SIZEX $clx SIZEY $cly]
		}
	}
	set new_area [dbShape [dbShape $area SIZE -$clx SIZEY -$clky] ANDNOT [dbGet $mem_list.boxes]]
	set new_area1 [dbShape $new_area AND [dbShape [dbGet $mem_list.boxes] SIZEX $clx]]
	set new_area2 [dbShape $new_area AND [dbShape [dbGet $mem_list.boxes] SIZEX $cly]]
	set return_area [dbShape $new_area1 OR $new_area2] ;
	set i 0
	foreach box $return_area {
		incr 1
		set size [my.util.get_width_height $box] ;
		set width [lindex $size 0] ;
		set height [lindex $size 1] ;
		createMarker -bbox $box -type channel_$i
		lappend return_box $box ;
	}
		
	if [info exist return_box] {
		return $return_box ;
	}
}
proc my.util.get_width_height {box} {
	set lx [lindex $box 0] ;
	set ly [lindex $box 1] ;
	set rx [lindex $box 2] ;
	set ry [lindex $box 3] ;
	set width [expr $rx - $lx];
	set height [expr $ry - $ly];
	return [list $width $height];
}
proc my.pd.add_power_switch_in_channel {} {
	global pgvars
	my.fp.block_core 30 30 hard
	set hInst [dbGet [dbGet top.pds.name $pgvars(domain) -p].group.members.name] ;
}
proc my.pd.add_power_switch {domain} {
	global pgvars
	set pgvars(domain) $domain
	my.fp.block_channel 15 2 hard
	#3 set pgvars(leftOffset)
	set pds [dbGet top.pds.name $pgvars(domain) -p]
	set pds_box [dbGet $pds.group.members.box -i 0]  ;; ????
	set hInst [dbGet $pds.group.members.name]
	set num_pitch [expr int(([lindex $pds_box 0] - $pgvars(leftOffset))/$pgvars(horizontalPitch))]
	set num [expr ([lindex $pds_box 0] - $pgvars(leftOffset))/$pgvars(horizontalPitch)]
	
	if { $num_pitch < $num } {
		incr num_pitch
	} ;
	set leftOffset [expr $pgvars(leftOffset) + $pgvars(horizontalPitch)*$num_pitch - [lindex $pds_box 0]] ;
	puts "************************* leftOffset $leftOffset **************************"
	set cmd "addPowerSwitch -column -incremental 0            \
		-powerDomain $pgvars(domain)                      \
		-skipRows $pdvars(skipRows)                       \
		-leftOffset $leftOffset                           \
		-horizontalPitch $pdvars(horizontalPitch)         \
		-instancePrefix PWRSH_$pdvars(domain)_core        \
		-globalSwitchCellName $pgvars(pso_cell)           \
		-switchModuleInstance $hInst                      \
		-noEnableChain                                    \
		$pdvars(add_pwrsh_option)"
	eval $cmd
	deletePlaceBlockage pb4channel_hard_*
	my.fp.block_for_channel_psw 15 2 hard
	#my.fp.block_core 15 2 hard
	set cmd "addPowerSwitch -column -incremental 1            \
		-powerDomain $pgvars(domain)                      \
		-instancePrefix PWRSH_$pdvars(domain)_channel     \
		-globalSwitchCellName $pgvars(channel_pso_cell)   \
		-skipRows $pdvars(channel_skipRows)               \
		-placementAdjustX $pgvars(channel_placementAdjustX) \
		-placeunderverticalnet {$pgvars(AON_POWER) $pgvars(AON_POWR_layer)}  \
		-switchModuleInstance $hInst                      \
		-noEnableChain                                    \
		$pdvars(channel_add_pwrsh_option)"
	eval $cmd
	deletePlaceBlockage *
}
proc my.pg.rechainPowerSwitch {domain} {
	set pgvars(domain) $domain
	set pgvars(enablePortIn) [list PD_EN_IN ] ;
	set pgvars(enablePortOut) [list PD_EN_OUT ] ;
	set hInst [dbGet [dbGet $top.pds.name $pgvars(domain) -p].group.members.name]
	if [info exist enableNetIn] {
		unset enableNetIn
	}
	foreach pin_name $pgvars(enablePortIn) {
		set pin [get_pins $hInst/$pin_name -quiect]
		if {[sizeof_collection $pin] == 0} {
			addModulePort $hInst $pin_name input
		}
		lappend enableNetIn $hInst/$pin_name"
	}
	if [info exist enableNetOut] {
		unset enableNetOut
	}
	foreach pin_name $pgvars(enablePortOut) {
		set pin [get_pins $hInst/$pin_name -quiect]
		if {[sizeof_collection $pin] == 0} {
			addModulePort $hInst $pin_name output
		}
		lappend enableNetOut $hInst/$pin_name"
	}
	set enablePinIn [dbGet [dbGet [dbGet head.libCells.name $pgvars(pso_cell) -p].terms.isInput 1 -p].name]
	set enablePinOut [dbGet [dbGet [dbGet head.libCells.name $pgvars(pso_cell) -p].terms.isOutput 1 -p].name]
	deselectAll
	dbSelectObj [dbGet [dbGet top.insts.cell.name $pgvars(pso_cell) -p2].pd.name $pgvars(domain) -p2 -e]
	rechainPowerSwitch -backToBackChain -selected \
		-enablePinIn $enablePinIn -enablePinOut $enablePinOut -maxDistanceY 100 -maxDistanceX 100 \
		-enableNetIn $enableNetIn -enableNetOut $enableNetOut
	dbSelectObj [dbGet [dbGet [dbGet top.insts.cell.name $pgvars(pso_cell) -p2].pd.name $pgvars(domain) -p2 -e].instTerms]

	set pds [dbGet top.pds.name $pgvars(domain) -p]
	set pds_box [dbGet $pds.group.members.box -i 0]  ;; ????
	
	
	
	
		createPlaceBlockage -box $box -type $type -name pb4channel_${type}_$i ;
	foreach box [dbShape $area SIZEX -$clx SIZEY -$cly] {
		incr i
	}
	

	###get boundray cells box for domain bourndary channel
	foreach domain $vars(power_domains) {
		set ${domain}_boundary_newadded_boxes ""
		if {[dbget [dbget top.pds.group.name $domain -p2].isDefault] ==1} {
			set shape1 $aon_domain_shapes_all
		else {
			set shape1 [set ${domain}_shapes]
		}
		foreach box $boundary_cells_boxes  {
			set or_poly [dbshape [dbshape [dbshape $box -output polygon] SIZEX 15 -output polygon] OR $shape1 -output polygon]
			set and_poly [dbshape [dbshape [dbshape $box -output polygon] -output polygon] AND $shape1 -output polygon]
			set and_mem_poly [dbshape [dbshape $block_shapes SIZEX 12] AND [dbshape $box -output polygon] -output polygon]
			if {$or_poly != $shape1 && $and_poly != "" && $and_mem_poly != ""} {
				lappend ${domain}_boundary_newadded_boxes $box
			}
		}
	}
	# add m5 on boundary cells
	foreach domain $vars(power_domains) {
		if {[dbget [dbget top.pds.group.name $domain -p2].isDefault] ==1} {
			set vars(PWR) $vars(AON_PWR)
			set ${domain}_channel_boundary_cells_shapes [dbshape $aon_domain_shapes_all AND $channel_boundary_cells_shapes -output rect]
		else {
			set vars(PWR) [regsub $vars(AON_PWR) [dbPowerDomainPNet $domain] ""]
			set ${domain}_channel_boundary_cells_shapes [dbshape [set ${domain}_shapes] AND $channel_boundary_cells_shapes -output rect]
		}
		set ${domain}_channel_boundary_cells_boxes [dbshape [set ${domain}_channel_boundary_cells_shapes] OR [set ${domain}_boundary_newadded_boxes] -output rect]
		setEdit -drc_on 1 -create_via_on_pin 0 -extend_end_wires 0 -extend_start_wires 0 -layer M5 -nets $vars(PWR) -force_special 1 -create_crossover_vias 0 \
			-shape RING -spacing 0.08 -subclass mem_ring -use_via_gen 0 -width 0.16 -layer_horizontal M5 -layer_vertical M5  -width_vertical 0.16 -width_horizontal 0.16
		foreach box [set ${domain}_channel_boundary_cells_boxes] {
			set lx [lindex $box 0]
			set ly [lindex $box 1]
			set rx [lindex $box 2]
			set ry [lindex $box 3]
			editAddRoute [expr $lx + 0.08] $ly
			editCommitRoute [expr $lx + 0.08] $ry
		}
		setEdit -drc_on 1 -create_via_on_pin 0 -extend_end_wires 0 -extend_start_wires 0 -layer M5 -nets $vars(GND) -force_special 1 -create_crossover_vias 0 \
			-shape RING -spacing 0.08 -subclass mem_ring -use_via_gen 0 -width 0.16 -layer_horizontal M5 -layer_vertical M5  -width_vertical 0.16 -width_horizontal 0.16
		foreach box [set ${domain}_channel_boundary_cells_boxes] {
			set lx [lindex $box 0]
			set ly [lindex $box 1]
			set rx [lindex $box 2]
			set ry [lindex $box 3]
			editAddRoute [expr $lx + 0.08 + 0.16 + 0.08] $ly
			editCommitRoute [expr $lx + 0.08 + 0.16 + 0.08] $ry
		}
	}
			
	# add m5 on channel for channel power switch			
	foreach domain $vars(power_domains) {
		if {[dbget [dbget top.pds.group.name $domain -p2].isDefault] ==1} {
			set vars(PWR) $vars(AON_PWR)
			set ${domain}_channel_boundary_cells_shapes [dbshape $aon_domain_shapes_all AND $channel_boundary_left_cells_shapes_size -output rect]
		else {
			set vars(PWR) [regsub $vars(AON_PWR) [dbPowerDomainPNet $domain] ""]
			set ${domain}_channel_boundary_cells_shapes [dbshape [set ${domain}_shapes] AND $channel_boundary_left_cells_shapes_size -output rect]
		}
		if {[dbget [dbget top.pds.group.name $domain -p2].isDefault] ==1} {
			setEdit -drc_on 1 -create_via_on_pin 0 -extend_end_wires 0 -extend_start_wires 0 -layer M5 -nets $vars(PWR) -force_special 1 -create_crossover_vias 0 \
				-shape RING -spacing 0.13 -subclass mem_ring -use_via_gen 0 -width 0.5 -layer_horizontal M5 -layer_vertical M5  -width_vertical 0.5 -width_horizontal 0.5
			foreach box [set ${domain}_channel_boundary_cells_shapes] {
				set lx [lindex $box 0]
				set ly [lindex $box 1]
				set rx [lindex $box 2]
				set ry [lindex $box 3]
				set new_box "$lx $ly [expr $rx + 6] $ry"
				set and_poly [dbShape $all_mem_shapes AND $new_box -output polygon]
				if { $and_poly ==""} {
					editAddRoute [expr $rx + $vars(m5channel_pffset)] $ly
					editCommitRoute [expr $rx + $vars(m5channel_pffset)] $ry
					editAddRoute [expr $rx + $vars(m5channel_pffset) + 0.5*3 + 0.13*3] $ly
					editCommitRoute [expr $rx + $vars(m5channel_pffset) + 0.5*3 + 0.13*3] $ry
				}
			}
			if {[set ${domain}_boxes] !=""} {
				foreach box [set ${domain}_boxes] {
					set lx [lindex $box 0]
					set ly [lindex $box 1]
					set rx [lindex $box 2]
					set ry [lindex $box 3]
					set new_box "$lx $ly [expr $rx + 6] $ry"
					set and_poly [dbShape $all_mem_shapes AND $new_box -output polygon]
				if { $and_poly ==""} {
					editAddRoute [expr $rx + $vars(m5channel_pffset)] $ly
					editCommitRoute [expr $rx + $vars(m5channel_pffset)] $ry
					editAddRoute [expr $rx + $vars(m5channel_pffset) + 0.5*3 + 0.13*3] $ly
					editCommitRoute [expr $rx + $vars(m5channel_pffset) + 0.5*3 + 0.13*3] $ry
				}
			}
		}
		setEdit -drc_on 1 -create_via_on_pin 0 -extend_end_wires 0 -extend_start_wires 0 -layer M5 -nets $vars(GND) -force_special 1 -create_crossover_vias 0 \
				-shape RING -spacing 0.13 -subclass mem_ring -use_via_gen 0 -width 0.5 -layer_horizontal M5 -layer_vertical M5  -width_vertical 0.5 -width_horizontal 0.5
		foreach box [set ${domain}_channel_boundary_cells_shapes] {
			set lx [lindex $box 0]
			set ly [lindex $box 1]
			set rx [lindex $box 2]
			set ry [lindex $box 3]
			set new_box "$lx $ly [expr $rx + 6] $ry"
			set and_poly [dbShape $all_mem_shapes AND $new_box -output polygon]
			if { $and_poly ==""} {
				editAddRoute [expr $rx + $vars(m5channel_pffset) + 0.5 + 0.13] $ly
				editCommitRoute [expr $rx + $vars(m5channel_pffset) + 0.5 + 0.13] $ry
				editAddRoute [expr $rx + $vars(m5channel_pffset) + 0.5*2 + 0.13*2] $ly
				editCommitRoute [expr $rx + $vars(m5channel_pffset) + 0.5*2 + 0.13*2] $ry
			}
		}
		if {[set ${domain}_boxes] !=""} {
			foreach box [set ${domain}_boxes] {
				set lx [lindex $box 0]
				set ly [lindex $box 1]
				set rx [lindex $box 2]
				set ry [lindex $box 3]
				set new_box "$lx $ly [expr $rx + 6] $ry"
				set and_poly [dbShape $all_mem_shapes AND $new_box -output polygon]
				if { $and_poly ==""} {
					editAddRoute [expr $rx + $vars(m5channel_pffset) + 0.5 + 0.13] $ly
					editCommitRoute [expr $rx + $vars(m5channel_pffset) + 0.5 + 0.13] $ry
					editAddRoute [expr $rx + $vars(m5channel_pffset) + 0.5*2 + 0.13*2] $ly
					editCommitRoute [expr $rx + $vars(m5channel_pffset) + 0.5*2 + 0.13*2] $ry
				}
			}
		}
	}
	uiSetTool select
	setEdit -reset
	}
}
