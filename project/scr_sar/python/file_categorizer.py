#!/bin/python3
# --------------------------
# author    : sar song
# date      : 2025/08/21 20:24:49 Thursday
# label     : 
#   -> (atomic_proc|display_proc|gui_proc|task_proc|dump_proc|check_proc|math_proc|package_proc|test_proc|datatype_proc|db_proc|misc_proc)
# descrip   : This script analyzes hierarchical paths from a file, enables users to specify categorization levels and keywords, 
#               then classifies paths into user-defined categories with empty lines separating different categories.
# usage     : Run the script with: python file_categorizer.py <input_file> [output_file] [--config config_file]
#             Use --config to specify a categorization rules file. Each line format: category:keyword1,keyword2(regular expressions supported)
# update    : 2025/08/29 16:28:16 Friday 
#             (compact display of level groups with original order)
# related   : NOTICE: This script can be used in conjunction with ./group_splitter.py: when the content generated by this script is written to 
#                   outputfile, outputfile can serve as the input file for ./group_splitter.py, which can then write different groups into 
#                   separate files. This makes it easy to capture filenames with the same suffix, process the content of each file in Tcl code, 
#                   write the content into a list, and also facilitates the management of configuration files.
# return    : output file
# ref       : link url
# --------------------------
import sys
import re
from collections import defaultdict

# Assume typical terminal width for compact display calculations
TERMINAL_WIDTH = 268        # you can change this number according to your actual terminal width
HALF_WIDTH = TERMINAL_WIDTH // 2

def analyze_file(file_path):
  """Analyze the file and find all possible categorization points for both directions"""
  paths = []
  # Store all possible values for each level in both directions
  levels_ltr = defaultdict(set)  # left-to-right levels
  levels_rtl = defaultdict(set)  # right-to-left levels
  
  with open(file_path, 'r') as f:
    for line in f:
      line = line.strip()
      if line:
        paths.append(line)
        # Split path into parts
        parts = line.split('/')
        # Skip empty strings (since paths start with /)
        parts = [p for p in parts if p]
        # Process left-to-right levels
        for i, part in enumerate(parts):
          levels_ltr[i].add(part)
        # Process right-to-left levels
        reversed_parts = list(reversed(parts))
        for i, part in enumerate(reversed_parts):
          levels_rtl[i].add(part)
  
  print("File analysis results:")
  print(f"Found {len(paths)} paths")
  
  return paths, levels_ltr, levels_rtl

def load_categories_from_file(config_path):
  """Load categories from a configuration file with regex support"""
  categories = {}
  
  try:
    with open(config_path, 'r') as f:
      for line_num, line in enumerate(f, 1):
        line = line.strip()
        if not line or line.startswith('#'):  # Skip empty lines and comments
          continue
        
        if ':' not in line:
          print(f"Warning: Invalid format in config file line {line_num}. Skipping.")
          continue
        
        cat_name, keywords = line.split(':', 1)
        cat_name = cat_name.strip()
        keywords = [k.strip() for k in keywords.split(',') if k.strip()]
        
        if not cat_name or not keywords:
          print(f"Warning: Incomplete entry in config file line {line_num}. Skipping.")
          continue
        
        categories[cat_name] = keywords
  
  except FileNotFoundError:
    print(f"Error: Config file {config_path} not found")
    sys.exit(1)
  except Exception as e:
    print(f"Error reading config file: {str(e)}")
    sys.exit(1)
  
  if not categories:
    print("Error: No valid categories found in config file")
    sys.exit(1)
  
  return categories

def create_compact_output(lines):
  """Create compact output by combining short lines when possible"""
  compact_lines = []
  i = 0
  
  while i < len(lines):
    # Check if current line is short enough to combine with next
    if i + 1 < len(lines):
      line1_len = len(lines[i])
      line2_len = len(lines[i+1])
      
      # Combine if both lines are shorter than half terminal width
      if line1_len < HALF_WIDTH and line2_len < HALF_WIDTH:
        # Calculate padding to align second column
        padding = ' ' * (HALF_WIDTH - line1_len)
        compact_lines.append(f"{lines[i]}{padding}{lines[i+1]}")
        i += 2  # Skip next line as we combined it
        continue
    
    # If not combining, add single line
    compact_lines.append(lines[i])
    i += 1
  
  return compact_lines

def display_level_groups(paths, level, direction, level_num):
  """Display groups for a specific level in compact format with original order"""
  # Collect entries in original order
  entries = []
  for path in paths:
    parts = [p for p in path.split('/') if p]  # Split path and remove empty strings
    
    # Get the relevant part based on direction
    if direction == 'ltr':
      if len(parts) > level:
        group_key = parts[level]
      else:
        group_key = "[Insufficient levels]"
    else:  # rtl
      reversed_parts = list(reversed(parts))
      if len(reversed_parts) > level:
        group_key = reversed_parts[level]
      else:
        group_key = "[Insufficient levels]"
    
    # Format entry as "group_key - path"
    entries.append(f"{group_key} - {path}")
  
  # Create compact output
  compact_entries = create_compact_output(entries)
  
  # Display the level information
  print(f"\n----- Level {level_num} -----")
  print(f"Total entries: {len(entries)}")
  for line in compact_entries:
    print(line)

def display_all_level_groups(paths, levels, direction):
  """Display all levels' groups in compact format after direction selection"""
  dir_label = "left-to-right" if direction == 'ltr' else "right-to-left"
  print(f"\n===== All {dir_label} Levels (Compact View) =====")
  print(f"Found {len(levels)} levels. Displaying entries in original order:")
  
  # Display each level's groups in order
  for level in sorted(levels.keys()):
    display_level_groups(paths, level, direction, level + 1)

def get_user_categories(levels_ltr, levels_rtl, config_file=None):
  """Get user-defined categorization rules with direction selection and config file support"""
  # Let user select categorization direction
  while True:
    direction = input("\nPlease select categorization direction (left-to-right/right-to-left) [l/r]: ").strip().lower()
    if direction in ['l', 'r', 'left', 'right', 'left-to-right', 'right-to-left']:
      # Normalize direction to 'ltr' or 'rtl'
      direction = 'ltr' if direction in ['l', 'left', 'left-to-right'] else 'rtl'
      break
    print("Invalid direction, please enter 'l' for left-to-right or 'r' for right-to-left")
  
  # Select appropriate levels based on direction
  levels = levels_ltr if direction == 'ltr' else levels_rtl
  dir_label = "left-to-right" if direction == 'ltr' else "right-to-left"
  
  # Display all levels' groups for the selected direction
  display_all_level_groups(paths, levels, direction)
  
  # Let user select categorization level
  while True:
    try:
      level = int(input(f"\nPlease select the {dir_label} level to use for categorization (number): ")) - 1  # Convert to 0-based index
      if level in levels:
        break
      print(f"Invalid level, please select a number between 1 and {len(levels)}")
    except ValueError:
      print("Please enter a valid number")
  
  # Show all possible values for the selected level
  print(f"\nAll possible values for {dir_label} level {level + 1}: {sorted(levels[level])}")
  
  # If config file is provided, use it
  if config_file:
    categories = load_categories_from_file(config_file)
  else:
    # Let user define categories interactively
    print("\nPlease define categories (enter 'done' to finish)")
    print("Format: category_name:keyword1,keyword2,... (supports regular expressions)")
    print("Example: TextFiles:txt$,doc,docx")
    
    categories = {}
    while True:
      entry = input("> ").strip()
      if entry.lower() == 'done':
        if categories:  # Ensure at least one category is defined
          break
        else:
          print("Please define at least one category")
          continue
      
      if ':' not in entry:
        print("Format error, please use 'category_name:keyword1,keyword2,...' format")
        continue
      
      cat_name, keywords = entry.split(':', 1)
      cat_name = cat_name.strip()
      keywords = [k.strip() for k in keywords.split(',') if k.strip()]
      
      if not cat_name or not keywords:
        print("Both category name and keywords cannot be empty")
        continue
      
      categories[cat_name] = keywords
  
  # Add an "Other" category for paths that don't match any keywords
  categories["Other"] = []
  
  return level, direction, categories

def categorize_paths(paths, level, direction, categories):
  """Categorize paths according to user-defined rules (supports regex) and selected direction"""
  categorized = defaultdict(list)
  
  for path in paths:
    parts = [p for p in path.split('/') if p]  # Split path and remove empty strings
    
    # Get the relevant part based on direction
    if direction == 'ltr':
      if len(parts) > level:
        path_part = parts[level]
      else:
        # Path doesn't have enough levels, put in "Other" category
        categorized["Other"].append(path)
        continue
    else:  # rtl
      reversed_parts = list(reversed(parts))
      if len(reversed_parts) > level:
        path_part = reversed_parts[level]
      else:
        # Path doesn't have enough levels, put in "Other" category
        categorized["Other"].append(path)
        continue
    
    # Find matching category using regex
    matched = False
    for cat_name, keywords in categories.items():
      if cat_name == "Other":
        continue  # Handle "Other" category last
      for keyword in keywords:
        try:
          if re.search(keyword, path_part):
            categorized[cat_name].append(path)
            matched = True
            break
        except re.error:
          print(f"Warning: Invalid regular expression '{keyword}' in category '{cat_name}'. Skipping.")
      if matched:
        break
    
    if not matched:
      categorized["Other"].append(path)
  
  return categorized

def output_results(categorized, output_file=None):
  """Output the categorization results"""
  output = []
  
  for cat_name, paths in categorized.items():
    if paths:  # Only output categories with content
      output.append(f"===== {cat_name} =====")
      output.extend(paths)
      output.append("")  # Add empty line between different categories
  
  # Remove the last empty line
  if output and output[-1] == "":
    output.pop()
  
  result = '\n'.join(output)
  
  if output_file:
    with open(output_file, 'w') as f:
      f.write(result)
    print(f"\nCategorization results saved to {output_file}")
  else:
    print("\nCategorization results:")
    print(result)

def main():
  global paths  # Make paths accessible to get_user_categories function
  # Parse command line arguments
  config_file = None
  args = sys.argv[1:]
  
  # Check for config file argument
  if "--config" in args:
    config_idx = args.index("--config")
    if config_idx + 1 < len(args):
      config_file = args[config_idx + 1]
      # Remove config arguments
      args.pop(config_idx)
      args.pop(config_idx)
  
  # Get input and output files
  if len(args) < 1:
    print("Usage: python file_categorizer.py <input_file> [output_file] [--config config_file]")
    sys.exit(1)
  
  input_file = args[0]
  output_file = args[1] if len(args) > 1 else None
  
  try:
    # Analyze the file
    paths, levels_ltr, levels_rtl = analyze_file(input_file)
    
    # Get user-defined categorization rules
    level, direction, categories = get_user_categories(levels_ltr, levels_rtl, config_file)
    
    # Categorize paths
    categorized = categorize_paths(paths, level, direction, categories)
    
    # Output results
    output_results(categorized, output_file)
    
  except FileNotFoundError:
    print(f"Error: File {input_file} not found")
    sys.exit(1)
  except Exception as e:
    print(f"An error occurred: {str(e)}")
    sys.exit(1)

if __name__ == "__main__":
  main()

