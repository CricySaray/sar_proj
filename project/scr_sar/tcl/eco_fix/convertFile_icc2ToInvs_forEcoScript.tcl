#!/bin/tclsh
# --------------------------
# author    : sar song
# date      : 2025/10/02 11:53:40 Thursday
# label     : atomic_proc
#   tcl  -> (atomic_proc|display_proc|gui_proc|task_proc|dump_proc|check_proc|math_proc|package_proc|test_proc|datatype_proc|db_proc|flow_proc|report_proc|cross_lang_proc|misc_proc)
#   perl -> (format_sub|getInfo_sub|perl_task)
# descrip   : Translate the ICC2 ECO script generated by PT into an ECO script suitable for INVS.
# return    : invs eco script
# related   : ~/project/scr_sar/perl/convert_icc2ToInvs_forEcoScript.perl
# ref       : link url
# --------------------------
proc convertFile_icc2ToInvs_forEcoScript {{input_file "fix_timing.icc2.tcl"} {output_file "fix_timing.invs.tcl"} {debug 0}} {
  # Initialize orientation mapping array
  array set invs_orient {
    FN "MY"
    FS "MX"
    S  "R180"
    N   "R0"
  }
  
  # Initialize variables
  set hinst ""
  set total_lines 0
  set matched_lines 0
  set in_fd ""
  set out_fd ""
  
  # Validate input file
  if {![file exists $input_file]} {
    error "proc convertFile_icc2ToInvs_forEcoScript: Input file error: $input_file does not exist"
  }
  if {![file readable $input_file]} {
    error "proc convertFile_icc2ToInvs_forEcoScript: Input file error: $input_file is not readable"
  }
  
  # Validate output directory
  set output_dir [file dirname $output_file]
  if {![file exists $output_dir]} {
    error "proc convertFile_icc2ToInvs_forEcoScript: Output directory error: $output_dir does not exist"
  }
  if {![file isdirectory $output_dir]} {
    error "proc convertFile_icc2ToInvs_forEcoScript: Output directory error: $output_dir is not a directory"
  }
  
  # Open files with error handling
  if {[catch {open $input_file r} in_fd]} {
    error "proc convertFile_icc2ToInvs_forEcoScript: Failed to open input file: $in_fd"
  }
  if {[catch {open $output_file w} out_fd]} {
    close $in_fd
    error "proc convertFile_icc2ToInvs_forEcoScript: Failed to open output file: $out_fd"
  }
  puts $out_fd "setEcoMode -reset"
  puts $out_fd "setEcoMode -batchMode true -updateTiming false -refinePlace false -honorDontTouch false -honorDontUse false -honorFixedNetWire false -honorFixedStatus false"
  puts $out_fd ""
  
  # Process each line
  while {[gets $in_fd line] != -1} {
    incr total_lines
    set line [string trimright $line "\n"] ;# Equivalent to chomp
    set line_matched 0
    
    # Handle current_instance (no argument)
    if {[regexp {^current_instance$} $line]} {
      set hinst ""
      set line_matched 1
      if {$debug} {
        puts "Debug: Reset current instance to empty"
      }
    # Handle current_instance (with argument)
    } elseif {[regexp {^current_instance\s+\{(\S+)\}} $line -> inst]} {
      set hinst "${inst}/"
      set line_matched 1
      if {$debug} {
        puts "Debug: Set current instance to $hinst"
      }
    }
    # Handle size_cell
    if {[regexp {^size_cell\s+\{(\S+)\}\s+\{(\S+)\}} $line -> inst cell]} {
      set full_inst "${hinst}${inst}"
      puts $out_fd "ecoChangeCell -inst \{$full_inst\} -cell $cell"
      set line_matched 1
      if {$debug} {
        puts "Debug: Converted size_cell for $full_inst to ecoChangeCell"
      }
    }
    
    # Handle remove_buffer
    if {[regexp {^remove_buffer\s+\[get_cells\s+\{(\S+)\}\]} $line -> inst]} {
      set full_inst "${hinst}${inst}"
      puts $out_fd "ecoDeleteRepeater -inst \{$full_inst\}"
      set line_matched 1
      if {$debug} {
        puts "Debug: Converted remove_buffer for $full_inst to ecoDeleteRepeater"
      }
    }
    
    # Handle set_cell_location
    if {[regexp {^set_cell_location} $line]} {
      set parts [split $line " "]
      if {[llength $parts] >= 8} {
        set x [lindex $parts 2]
        regsub -all {\{} $x "" x
        set y [lindex $parts 3]
        regsub -all {\}} $y "" y
        set orient [lindex $parts 5]
        set inst [lindex $parts 7]
        regsub {^\{} $inst "" inst
        regsub {\]$} $inst "" inst
        regsub {\}$} $inst "" inst
        regsub {.*\/} $inst "" inst
        set full_inst "${hinst}${inst}"
        
        if {[info exists invs_orient($orient)]} {
          set mapped_orient $invs_orient($orient)
          puts $out_fd "placeInstance \{$full_inst\} $x $y $mapped_orient -placed"
          set line_matched 1
          if {$debug} {
            puts "Debug: Converted set_cell_location for $full_inst to placeInstance"
          }
        }
      }
    }
    
    # Handle add_buffer_on_route
    if {[regexp {^add_buffer_on_route \[get_net -of \{(\S+)\}\] -user_specified_buffers \{ (.*)\} -no_legalize} $line -> pin buffer_pattern]} {
      set full_pin "${hinst}${pin}"
      set buffer_parts [split $buffer_pattern " "]
      set i 0
      set new_inst ""
      set cell ""
      set x ""
      set y ""
      
      foreach part $buffer_parts {
        switch [expr {$i % 5}] {
          0 { set new_inst $part }
          1 { set cell $part }
          2 { set x $part }
          3 { set y $part }
          4 {
            set hinstGuide $hinst
            regsub {/$} $hinstGuide "" hinstGuide
            puts $out_fd "ecoAddRepeater -net \[join \[dbget \[dbget -p top.insts.instTerms.name \{$full_pin\}\].net.name\]\] -cell $cell -name $new_inst -hinstGuide \{$hinstGuide\} -loc \{$x $y\}"
            if {$debug} {
              puts "Debug: Converted add_buffer_on_route for $new_inst"
            }
          }
        }
        incr i
      }
      set line_matched 1
    }
    
    # Handle insert_buffer
    if {[regexp {^insert_buffer} $line]} {
      set parts [split $line " "]
      set num_parts [llength $parts]
      set eco_type ""
      set pin [lindex $parts 2]
      set cell [lindex $parts 3]
      set new_net [lindex $parts 5]
      set new_inst [lindex $parts 7]
      set x ""
      set y ""
      set orient ""
      
      if {$num_parts == 8} {
        set eco_type "logic"
      } elseif {$num_parts == 11} {
        set eco_type "logic"
        set new_net [join [list [lindex $parts 6] [lindex $parts 7]] " "]
        set new_inst [join [list [lindex $parts 9] [lindex $parts 10]] " "]
      } elseif {$num_parts == 13} {
        set eco_type "physical"
        set x [lindex $parts 9]
        set y [lindex $parts 10]
        set orient [lindex $parts 12]
        regsub {^\{} $x "" x
        regsub {\}$} $y "" y
      }
      
      # Clean up pin name
      regsub {^\{} $pin "" pin
      regsub {\}\]$} $pin "" pin
      set full_pin "${hinst}${pin}"
      
      # Clean up net and instance names
      regsub {^\{} $new_net "" new_net
      regsub {\}$} $new_net "" new_net
      regsub {^\{} $new_inst "" new_inst
      regsub {\}$} $new_inst "" new_inst
      
      # Prepare hinstGuide
      set hinstGuide $hinst
      regsub {/$} $hinstGuide "" hinstGuide
      
      # Generate output command
      if {$eco_type eq "logic"} {
        puts $out_fd "ecoAddRepeater -term \{$full_pin\} -cell $cell -hinstGuide \{$hinstGuide\} -name $new_inst -newNetName $new_net -loc \[dbget \[dbget -p top.insts.instTerms.name \{$full_pin\}\].pt\]"
        if {$debug} {
          puts "Debug: Converted logic insert_buffer for $new_inst"
        }
      } elseif {$eco_type eq "physical"} {
        if {[info exists orient] && [info exists invs_orient($orient)]} {
          set mapped_orient $invs_orient($orient)
          puts $out_fd "ecoAddRepeater -term \{$full_pin\} -cell $cell -hinstGuide \{$hinstGuide\} -name $new_inst -newNetName $new_net -loc \{$x $y\} -bufOrient $mapped_orient"
        } else {
          puts $out_fd "ecoAddRepeater -term \{$full_pin\} -cell $cell -hinstGuide \{$hinstGuide\} -name $new_inst -newNetName $new_net -loc \{$x $y\}"
        }
        if {$debug} {
          puts "Debug: Converted physical insert_buffer for $new_inst"
        }
      }
      set line_matched 1
    }
    
    if {$line_matched} {
      incr matched_lines
    }
  }
  puts $out_fd ""
  puts $out_fd "setEcoMode -reset"
  
  # Close files
  close $in_fd
  close $out_fd
  
  # Handle no matched lines case
  if {$matched_lines == 0} {
    puts "Warning: No matched lines found in input file $input_file"
    set out_fd [open $output_file a]
    puts $out_fd "Error: no matched line from input file."
    close $out_fd
  }
  
  # Print summary
  puts "Processing Summary:"
  puts "Total lines processed: $total_lines"
  puts "Total lines converted: $matched_lines"
}
